"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   addReaction: () => (/* binding */ addReaction),\n/* harmony export */   applyOptimisticUpdates: () => (/* binding */ applyOptimisticUpdates),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   removeReaction: () => (/* binding */ removeReaction),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   upsertComment: () => (/* binding */ upsertComment),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.11.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let flagger;\n  const promise = new Promise((res) => {\n    flagger = res;\n  });\n  if (!flagger) {\n    throw new Error(\"Should never happen\");\n  }\n  return [promise, flagger];\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n  switch (status) {\n    case \"connecting\":\n      return \"connecting\";\n    case \"connected\":\n      return \"open\";\n    case \"reconnecting\":\n      return \"unavailable\";\n    case \"disconnected\":\n      return \"failed\";\n    case \"initial\":\n      return \"closed\";\n    default:\n      return \"closed\";\n  }\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getLegacyStatus() {\n    return newToLegacyStatus(this.getStatus());\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      verifyTokenPermissions(parsed, options);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          verifyTokenPermissions(parsed, options);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  function verifyTokenPermissions(parsedToken, options) {\n    if (!options.roomId && parsedToken.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      if (Object.entries(parsedToken.parsed.perms).length === 0) {\n        return;\n      }\n      for (const [resource, scopes] of Object.entries(\n        parsedToken.parsed.perms\n      )) {\n        if (resource.includes(\"*\") && hasCorrespondingScopes(options.requestedScope, scopes)) {\n          return;\n        }\n      }\n      throw new StopRetrying(\n        \"The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storage.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_DELAY = 100;\nvar noop = () => {\n};\nvar BatchCall = class {\n  constructor(args) {\n    this.resolve = noop;\n    this.reject = noop;\n    this.promise = new Promise(noop);\n    this.args = args;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n    try {\n      const results = await this.callback(args);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(...args) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.args) === stringify(args)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(args);\n    call.promise = new Promise((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n    eventSource2.notify(state);\n  }\n  async function get(...args) {\n    const cacheKey = getCacheKey(args);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(...args);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList();\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: user\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    const response = await fetchCommentsApi(\n      \"/threads/search\",\n      {\n        since: options?.since?.toISOString()\n      },\n      {\n        body: JSON.stringify({\n          ...options?.query?.metadata && { metadata: options.query.metadata }\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\"\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\n      \"/threads\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n  const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        activeBatch.ops.push(...ops);\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    connection: makeEventSource(),\n    // Old/deprecated API\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storage: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n          isReadOnly: !canWrite\n          // Deprecated, kept for backward-compatibility\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        context.root.set(key, cloneLson(context.initialStorage[key]));\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storage.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    context.buffer.storageOperations.push(...ops);\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    storage: eventHub.storage.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getConnectionState: () => managedSocket.getLegacyStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storage.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storage.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"connection\": {\n          const cb = callback;\n          return events.status.subscribe(\n            (status) => cb(newToLegacyStatus(status))\n          );\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storage.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.threadId !== threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    }\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1)\n        return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0)\n      return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1)\n        return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(info) {\n    const leave = () => {\n      const self = leave;\n      if (!info.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (info.unsubs.size === 0) {\n          teardownRoom(info.room);\n        }\n      }\n    };\n    info.unsubs.add(leave);\n    return {\n      room: info.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, options2) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    deprecateIf(\n      options2.initialPresence === null || options2.initialPresence === void 0,\n      \"Please provide an initial presence value for the current user when entering the room.\"\n    );\n    const newRoom = createRoom(\n      {\n        initialPresence: options2.initialPresence ?? {},\n        initialStorage: options2.initialStorage\n      },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomInfo = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomInfo);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomInfo);\n  }\n  function enter(roomId, options2) {\n    const { room, leave: _ } = enterRoom(roomId, options2);\n    return room;\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function forceLeave(roomId) {\n    const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      logout,\n      // Old, deprecated APIs\n      enter,\n      getRoom,\n      leave: forceLeave,\n      // New, preferred API\n      enterRoom,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0)\n    return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLHFHQUFxRyxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLFVBQVU7QUFDaEMsV0FBVyxTQUFTLEVBQUUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQSxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQzNDLGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssUUFBUSxTQUFTLFVBQVUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCw0RkFBNEY7QUFDL0k7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLGNBQWM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQixxRUFBcUUsR0FBRyxZQUFZLG1CQUFtQixTQUFTO0FBQ3RJO0FBQ0EsOENBQThDLE9BQU87QUFDckQsTUFBTTtBQUNOLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnRUFBZ0UsU0FBUyxLQUFLO0FBQzlFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWMsbUNBQW1DLFNBQVMsYUFBYTtBQUN2SDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLHlCQUF5QixJQUFJLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLEdBQUcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQztBQUMzQztBQUNBO0FBQ0EsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0R0FBNEcsYUFBYSxZQUFZLGVBQWU7QUFDcEo7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0IsSUFBSTtBQUM1RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sbUNBQW1DLG1CQUFtQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUscUJBQXFCLE9BQU8sR0FBRyxLQUFLO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNU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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0NBQWdDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0NBQXNDO0FBQ25IO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsd0NBQXdDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSw0QkFBNEIsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVEsb0JBQW9CLHVCQUF1QixNQUFNLElBQUksUUFBUSxRQUFRLHFCQUFxQixzQkFBc0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFHTjtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBeURFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWdtYS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzP2U5MDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvY29yZVwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIxLjExLjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgZmxhZ2dlcjtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBmbGFnZ2VyID0gcmVzO1xuICB9KTtcbiAgaWYgKCFmbGFnZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgfVxuICByZXR1cm4gW3Byb21pc2UsIGZsYWdnZXJdO1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihyYXdNZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmF3TWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGI2NGRlY29kZShiNjR2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gYjY0dmFsdWUucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgZGVjb2RlZFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgYXRvYihmb3JtYXR0ZWRWYWx1ZSkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oXCJcIilcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBhdG9iKGI2NHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcGFjdChpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKFxuICAgIChpdGVtKSA9PiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHZvaWQgMFxuICApO1xufVxuZnVuY3Rpb24gY29tcGFjdE9iamVjdChvYmopIHtcbiAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBpZiAobmV3T2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG5ld09ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtaWxsaXMsIGVycm1zZykge1xuICBsZXQgdGltZXJJRDtcbiAgY29uc3QgdGltZXIkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHRpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJybXNnKSk7XG4gICAgfSwgbWlsbGlzKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVyJF0pLmZpbmFsbHkoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySUQpKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL1NlcnZlck1zZy50c1xudmFyIFNlcnZlck1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNc2dDb2RlMikgPT4ge1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfSk9JTkVEXCJdID0gMTAxXSA9IFwiVVNFUl9KT0lORURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0xFRlRcIl0gPSAxMDJdID0gXCJVU0VSX0xFRlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJCUk9BRENBU1RFRF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVEVEX0VWRU5UXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUk9PTV9TVEFURVwiXSA9IDEwNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIl0gPSAyMDBdID0gXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfQ1JFQVRFRFwiXSA9IDQwMl0gPSBcIkNPTU1FTlRfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfRURJVEVEXCJdID0gNDAzXSA9IFwiQ09NTUVOVF9FRElURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0RFTEVURURcIl0gPSA0MDRdID0gXCJDT01NRU5UX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCJdID0gNDA1XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiXSA9IDQwNl0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9OT1JNQUxcIl0gPSAxZTNdID0gXCJDTE9TRV9OT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiUk9PTV9JRF9VUERBVEVEXCJdID0gNDAwNl0gPSBcIlJPT01fSURfVVBEQVRFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiBuZXdUb0xlZ2FjeVN0YXR1cyhzdGF0dXMpIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcIm9wZW5cIjtcbiAgICBjYXNlIFwicmVjb25uZWN0aW5nXCI6XG4gICAgICByZXR1cm4gXCJ1bmF2YWlsYWJsZVwiO1xuICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuICAgIGNhc2UgXCJpbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJjbG9zZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkIChjb2RlOiAke2V2ZW50LmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkxpdmVibG9ja3NFcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChlcnJtc2csIGVycmNvZGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gbmV3IExpdmVibG9ja3NFcnJvcihlcnJtc2csIGVycmNvZGUpO1xuICAgICAgb25MaXZlYmxvY2tzRXJyb3Iubm90aWZ5KGVycik7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25MaXZlYmxvY2tzRXJyb3I6IG9uTGl2ZWJsb2Nrc0Vycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMubWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5jbGVhbnVwcyA9IGNsZWFudXBzO1xuICB9XG4gIGdldExlZ2FjeVN0YXR1cygpIHtcbiAgICByZXR1cm4gbmV3VG9MZWdhY3lTdGF0dXModGhpcy5nZXRTdGF0dXMoKSk7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICB2ZXJpZnlUb2tlblBlcm1pc3Npb25zKHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKG9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgICB2ZXJpZnlUb2tlblBlcm1pc3Npb25zKHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHZlcmlmeVRva2VuUGVybWlzc2lvbnMocGFyc2VkVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucm9vbUlkICYmIHBhcnNlZFRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKHBhcnNlZFRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICBwYXJzZWRUb2tlbi5wYXJzZWQucGVybXNcbiAgICAgICkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKG9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVGhlIGlzc3VlZCBhY2Nlc3MgdG9rZW4gZG9lc24ndCBncmFudCBlbm91Z2ggcGVybWlzc2lvbnMuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYWNjZXNzLXRva2Vucy1ub3QtZW5vdWdoLXBlcm1pc3Npb25zXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0T3B0aW9ucykge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoMiwgZW5kcG9pbnQsIGJvZHkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gyKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIFwibWVcIiBvciBcIm90aGVyc1wiIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY01lKHJvb20pKSxcbiAgICByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSB5ZG9jIGlzIHVwZGF0ZWQsIGZvcndhcmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKCh1cGRhdGUpID0+IHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkpLFxuICAgIC8vIEFueSB0aW1lIGEgY3VzdG9tIHJvb20gZXZlbnQgaXMgcmVjZWl2ZWQsIGZvcndhcmQgaXRcbiAgICByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnREYXRhKSA9PiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKVxuICAgIClcbiAgXSk7XG59XG5mdW5jdGlvbiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjp5ZG9jXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cbnZhciBsb2FkZWRBdCA9IERhdGUubm93KCk7XG52YXIgZXZlbnRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICByZXR1cm4gYGV2ZW50LSR7bG9hZGVkQXR9LSR7ZXZlbnRDb3VudGVyKyt9YDtcbn1cbmZ1bmN0aW9uIGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpldmVudHM6OmN1c3RvbS1ldmVudFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogXCJDdXN0b21FdmVudFwiLFxuICAgICAgaWQ6IG5leHRFdmVudElkKCksXG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGNvbm5lY3Rpb25JZDogZXZlbnREYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgIHBheWxvYWQ6IGV2ZW50RGF0YS5ldmVudFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGlmIChyb290KSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIHN0b3JhZ2U6IHJvb3QudG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY01lKHJvb20pIHtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBpZiAobWUpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgbWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkge1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIGlmIChvdGhlcnMpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgb3RoZXJzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bGxTeW5jKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICByb29tLmZldGNoWURvYyhcIlwiKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpmdWxsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKSxcbiAgICBzdG9yYWdlOiByb290Py50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkID8/IG51bGwsXG4gICAgbWUsXG4gICAgb3RoZXJzXG4gIH0pO1xufVxudmFyIHJvb21DaGFubmVsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCkge1xuICBjb25zdCBsaXN0ZW5lciA9IHJvb21DaGFubmVsTGlzdGVuZXJzLmdldChyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5kZWxldGUocm9vbUlkKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlua0RldlRvb2xzKHJvb21JZCwgcm9vbSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsIHJvb21JZCwgY2xpZW50VmVyc2lvbjogVkVSU0lPTiB9KTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuc2V0KFxuICAgIHJvb21JZCxcbiAgICAvLyBSZXR1cm5zIHRoZSB1bnN1YnNjcmliZSBjYWxsYmFjaywgdGhhdCB3ZSBzdG9yZSBpbiB0aGVcbiAgICAvLyByb29tQ2hhbm5lbExpc3RlbmVycyByZWdpc3RyeVxuICAgIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAgIGNhc2UgXCJyb29tOjpzdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0YXJ0U3luY1N0cmVhbShyb29tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJvb206OnVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1bmxpbmtEZXZUb29scyhyb29tSWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6dW5hdmFpbGFibGVcIixcbiAgICByb29tSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKTtcbiAgfVxuICBjb25zdCBzb3J0ZWRPYmplY3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5yZWR1Y2UoXG4gICAgKHNvcnRlZE9iamVjdDIsIGtleSkgPT4ge1xuICAgICAgc29ydGVkT2JqZWN0MltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gc29ydGVkT2JqZWN0MjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0ZWRPYmplY3QsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgREVGQVVMVF9ERUxBWSA9IDEwMDtcbnZhciBub29wID0gKCkgPT4ge1xufTtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnJlc29sdmUgPSBub29wO1xuICAgIHRoaXMucmVqZWN0ID0gbm9vcDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnM/LnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zPy5kZWxheSA/PyBERUZBVUxUX0RFTEFZO1xuICB9XG4gIGNsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICB2b2lkIHRoaXMuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuZmx1c2goKSwgdGhpcy5kZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWxscyA9IHRoaXMucXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGFyZ3MgPSBjYWxscy5tYXAoKGNhbGwpID0+IGNhbGwuYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmNhbGxiYWNrKGFyZ3MpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QobmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxscy5sZW5ndGggIT09IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBwcm92aWRlZCBpdGVtcy4gRXhwZWN0ZWQgJHtjYWxscy5sZW5ndGh9LCBidXQgZ290ICR7cmVzdWx0cy5sZW5ndGh9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMucXVldWUuZmluZChcbiAgICAgIChjYWxsMikgPT4gc3RyaW5naWZ5KGNhbGwyLmFyZ3MpID09PSBzdHJpbmdpZnkoYXJncylcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoYXJncyk7XG4gICAgY2FsbC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2FsbC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIGNhbGwucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHRoaXMucXVldWUucHVzaChjYWxsKTtcbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RvcmUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgYmF0Y2ggPSBuZXcgQmF0Y2goY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgIH1cbiAgICBldmVudFNvdXJjZTIubm90aWZ5KHN0YXRlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoYXJncyk7XG4gICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoLmdldCguLi5hcmdzKTtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHJlc3VsdCB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhcmdzKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMixcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jcmVhdGUtc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNhbGxiYWNrKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2NvbnZlcnQtcGxhaW4tZGF0YS50c1xuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudERhdGEoZGF0YSkge1xuICBjb25zdCBlZGl0ZWRBdCA9IGRhdGEuZWRpdGVkQXQgPyBuZXcgRGF0ZShkYXRhLmVkaXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCByZWFjdGlvbnMgPSBkYXRhLnJlYWN0aW9ucy5tYXAoKHJlYWN0aW9uKSA9PiAoe1xuICAgIC4uLnJlYWN0aW9uLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUocmVhY3Rpb24uY3JlYXRlZEF0KVxuICB9KSk7XG4gIGlmIChkYXRhLmJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdCxcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERhdGEoZGF0YSkge1xuICBjb25zdCB1cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdCA/IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCBjb21tZW50cyA9IGRhdGEuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KVxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0LFxuICAgIHVwZGF0ZWRBdCxcbiAgICBjb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihkYXRhKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGRhdGEpIHtcbiAgY29uc3Qgbm90aWZpZWRBdCA9IG5ldyBEYXRlKGRhdGEubm90aWZpZWRBdCk7XG4gIGNvbnN0IHJlYWRBdCA9IGRhdGEucmVhZEF0ID8gbmV3IERhdGUoZGF0YS5yZWFkQXQpIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgdXJsLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL25vdGlmaWNhdGlvbnMudHNcbnZhciBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBjdXJyZW50VXNlcklkU3RvcmUsXG4gIGZldGNoZXJcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgfSk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiICYmIGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQudWlkO1xuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLnNldCgoKSA9PiB1c2VySWQpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKGJhc2VVcmwsIGAvdjIvYyR7ZW5kcG9pbnR9YCwgcGFyYW1zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoZXIodXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHZvaWQgMCwge1xuICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0LFxuICAgICAgc2luY2U6IG9wdGlvbnM/LnNpbmNlPy50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICApLFxuICAgICAgbWV0YToge1xuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvY291bnRcIik7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHM6IFwiYWxsXCIgfSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbCA/IHRoaXMuX19wb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLl9faWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy5fX2lkIHx8IHRoaXMuX19wb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuX19pZCA9IGlkO1xuICAgIHRoaXMuX19wb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuX19wb29sICYmIHRoaXMuX19pZCkge1xuICAgICAgdGhpcy5fX3Bvb2wuZGVsZXRlTm9kZSh0aGlzLl9faWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG5mdW5jdGlvbiBuYW5vaWQobGVuZ3RoID0gNykge1xuICBjb25zdCBhbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODksLi87W11+IUAjJCUmKigpXys9LVwiO1xuICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XG4gIHJldHVybiBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoIH0sXG4gICAgKCkgPT4gYWxwaGFiZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbikpXG4gICkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KCk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpIHtcbiAgICBjb25zdCBwYXJlbnRUb0NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXNSb290Q3JkdChjcmR0KSkge1xuICAgICAgICByb290ID0gW2lkLCBjcmR0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gW2lkLCBjcmR0XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChjcmR0LnBhcmVudElkKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHR1cGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb0NoaWxkcmVuLnNldChjcmR0LnBhcmVudElkLCBbdHVwbGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjYW4ndCBiZSBudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tSXRlbXMoaXRlbXMsIHBvb2wpIHtcbiAgICBjb25zdCBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl0gPSBfTGl2ZU9iamVjdC5fYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcyk7XG4gICAgcmV0dXJuIF9MaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRUb0NoaWxkcmVuLFxuICAgICAgcG9vbFxuICAgICk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wLCBcIlVua25vd24gY3JlYXRpb24gT3BcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIHJldHVybiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUucGFyZW50Lm5vZGUsIHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gTGl2ZVJlZ2lzdGVyLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBjcmR0LmRhdGE7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVMaXN0KHZhbHVlKSB8fCBpc0xpdmVNYXAodmFsdWUpIHx8IGlzTGl2ZU9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHx8IGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNMaXZlUmVnaXN0ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyO1xufVxuZnVuY3Rpb24gY2xvbmVMc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gbGl2ZU5vZGVUb0xzb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZUxpc3QgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob2JqLCBcIlVua25vd24gQWJzdHJhY3RDcmR0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBsc29uVG9MaXZlTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ld0l0ZW1zKSB7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjdXJyZW50SXRlbXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBpZiAoIW5ld0l0ZW1zLmdldChpZCkpIHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5ld0l0ZW1zLmZvckVhY2goKGNyZHQsIGlkKSA9PiB7XG4gICAgY29uc3QgY3VycmVudENyZHQgPSBjdXJyZW50SXRlbXMuZ2V0KGlkKTtcbiAgICBpZiAoY3VycmVudENyZHQpIHtcbiAgICAgIGlmIChjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q3JkdC50eXBlICE9PSAwIC8qIE9CSkVDVCAqLyB8fCBKU09OLnN0cmluZ2lmeShjcmR0LmRhdGEpICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50Q3JkdC5kYXRhKSkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjcmR0LnBhcmVudEtleSAhPT0gY3VycmVudENyZHQucGFyZW50S2V5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhcmVudEtleTogbm4oY3JkdC5wYXJlbnRLZXksIFwiUGFyZW50IGtleSBtdXN0IG5vdCBiZSBtaXNzaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgICAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTElTVCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwIC8qIE9CSkVDVCAqLzpcbiAgICAgICAgICBpZiAoY3JkdC5wYXJlbnRJZCA9PT0gdm9pZCAwIHx8IGNyZHQucGFyZW50S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvci4gQ2Fubm90IHNlcmlhbGl6ZSBzdG9yYWdlIHJvb3QgaW50byBhbiBvcGVyYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE1BUCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXM6IHVwZGF0ZXMuY29uY2F0KHNlY29uZC51cGRhdGVzKVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTWFwXCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU1hcFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTGlzdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVMaXN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSB7XG4gIH1cbiAgcmV0dXJuIHNlY29uZDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzUGxhaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCB8fCBcInJvb3RcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmICghaXNQbGFpbihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXG4gICAgICAgIG5lc3RlZFZhbHVlLFxuICAgICAgICBuZXN0ZWRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvQ2xpZW50TXNnLnRzXG52YXIgQ2xpZW50TXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsaWVudE1zZ0NvZGUyKSA9PiB7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiQlJPQURDQVNUX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNUX0VWRU5UXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfU1RPUkFHRVwiXSA9IDIwMF0gPSBcIkZFVENIX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfWURPQ1wiXSA9IDMwMF0gPSBcIkZFVENIX1lET0NcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMV0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIHJldHVybiBDbGllbnRNc2dDb2RlMjtcbn0pKENsaWVudE1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvcmVmcy9JbW11dGFibGVSZWYudHNcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBJbW11dGFibGVSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIH1cbiAgZ2V0IGRpZEludmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2Lm9ic2VydmFibGU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9ldi5ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlID8/ICh0aGlzLl9jYWNoZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9PdGhlcnNSZWYudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBPdGhlcnNSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCB1c2VycyA9IGNvbXBhY3QoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3ByZXNlbmNlcy5rZXlzKCkpLm1hcChcbiAgICAgICAgKGNvbm5lY3Rpb25JZCkgPT4gdGhpcy5nZXRVc2VyKE51bWJlcihjb25uZWN0aW9uSWQpKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG4gIGNsZWFyT3RoZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29ubiAhPT0gdm9pZCAwICYmIHByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjYWNoZWRVc2VyID0gdGhpcy5fdXNlcnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLl9nZXRVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbXB1dGVkVXNlcikge1xuICAgICAgdGhpcy5fdXNlcnMuc2V0KGNvbm5lY3Rpb25JZCwgY29tcHV0ZWRVc2VyKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVzZXI7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl91c2Vycy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBrbm93biBjb25uZWN0aW9uLiBUaGlzIHJlY29yZHMgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRoZVxuICAgKiBhc3NvY2lhdGVkIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIG1ldGFVc2VySWQsIG1ldGFVc2VySW5mbywgc2NvcGVzKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuc2V0KFxuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgZnJlZXplKHtcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgaW5mbzogbWV0YVVzZXJJbmZvLFxuICAgICAgICBzY29wZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5fcHJlc2VuY2VzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGtub3duIGNvbm5lY3Rpb25JZC4gUmVtb3ZlcyBib3RoIHRoZSBjb25uZWN0aW9uJ3MgbWV0YWRhdGEgYW5kXG4gICAqIHRoZSBwcmVzZW5jZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIG5ldyB1c2VyIGZyb20gYSBmdWxsIHByZXNlbmNlIHVwZGF0ZS4gSWYgdGhlIHVzZXIgYWxyZWFkeSBleGlzdHMsXG4gICAqIGl0cyBrbm93biBwcmVzZW5jZSBkYXRhIGlzIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgc2V0T3RoZXIoY29ubmVjdGlvbklkLCBwcmVzZW5jZSkge1xuICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUoY29tcGFjdE9iamVjdChwcmVzZW5jZSkpKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBwcmVzZW5jZSBkYXRhIGZvciBhbiBleGlzdGluZyBcIm90aGVyXCIuIElmIHdlIGRvbid0IGtub3cgdGhlXG4gICAqIGluaXRpYWwgcHJlc2VuY2UgZGF0YSBmb3IgdGhpcyB1c2VyIHlldCwgZGlzY2FyZCB0aGlzIHBhdGNoIGFuZCBhd2FpdCB0aGVcbiAgICogZnVsbCAuc2V0T3RoZXIoKSBjYWxsIGZpcnN0LlxuICAgKi9cbiAgcGF0Y2hPdGhlcihjb25uZWN0aW9uSWQsIHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkUHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgIGlmIChvbGRQcmVzZW5jZSAhPT0gbmV3UHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUobmV3UHJlc2VuY2UpKTtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9QYXRjaGFibGVSZWYudHNcbnZhciBQYXRjaGFibGVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBuZXdEYXRhID0gbWVyZ2Uob2xkRGF0YSwgcGF0Y2gpO1xuICAgIGlmIChvbGREYXRhICE9PSBuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZnJlZXplKG5ld0RhdGEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9WYWx1ZVJlZi50c1xudmFyIFZhbHVlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxufTtcbnZhciBEZXJpdmVkUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3Qgb3RoZXJSZWZzID0gYXJncztcbiAgICB0aGlzLl9yZWZzID0gb3RoZXJSZWZzO1xuICAgIHRoaXMuX3JlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICByZWYuZGlkSW52YWxpZGF0ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnZhbGlkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybUZuO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oXG4gICAgICAuLi50aGlzLl9yZWZzLm1hcCgocmVmKSA9PiByZWYuY3VycmVudClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSAxMDI0O1xuZnVuY3Rpb24gbWFrZUlkRmFjdG9yeShjb25uZWN0aW9uSWQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuICgpID0+IGAke2Nvbm5lY3Rpb25JZH06JHtjb3VudCsrfWA7XG59XG5mdW5jdGlvbiB1c2VyVG9UcmVlTm9kZShrZXksIHVzZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlVzZXJcIixcbiAgICBpZDogYCR7dXNlci5jb25uZWN0aW9uSWR9YCxcbiAgICBrZXksXG4gICAgcGF5bG9hZDogdXNlclxuICB9O1xufVxuZnVuY3Rpb24gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCBpbkJhY2tncm91bmRTaW5jZSA9IHsgY3VycmVudDogbnVsbCB9O1xuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA/PyBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICBkb2M/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIHJldHVybiBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuc3ViXTtcbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRzQXBpKHJvb21JZCwgZ2V0QXV0aFZhbHVlLCBmZXRjaENsaWVudEFwaSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBnZXRBdXRoVmFsdWUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbihlbmRwb2ludCwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBcIi90aHJlYWRzL3NlYXJjaFwiLFxuICAgICAge1xuICAgICAgICBzaW5jZTogb3B0aW9ucz8uc2luY2U/LnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5vcHRpb25zPy5xdWVyeT8ubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogb3B0aW9ucy5xdWVyeS5tZXRhZGF0YSB9XG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczoganNvbi5kYXRhLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgICApLFxuICAgICAgICBkZWxldGVkVGhyZWFkczoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoXG4gICAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICAgKSxcbiAgICAgICAgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uczoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICAgICksXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IFtdLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICBkZWxldGVkVGhyZWFkczogW10sXG4gICAgICAgIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgcmVxdWVzdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZHMuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgYC90aHJlYWQtd2l0aC1ub3RpZmljYXRpb24vJHt0aHJlYWRJZH1gXG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IGNvbnZlcnRUb1RocmVhZERhdGEoanNvbi50aHJlYWQpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjoganNvbi5pbmJveE5vdGlmaWNhdGlvbiA/IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShqc29uLmluYm94Tm90aWZpY2F0aW9uKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7dGhyZWFkSWR9LmApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQoe1xuICAgIG1ldGFkYXRhLFxuICAgIGJvZHksXG4gICAgY29tbWVudElkLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICBjb25zdCB0aHJlYWQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBcIi90aHJlYWRzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0VGhyZWFkTWV0YWRhdGEoe1xuICAgIG1ldGFkYXRhLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQyKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWRcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbjIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgY29uc3QgcmVhY3Rpb24gPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uMih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoZW1vamkpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRUaHJlYWRzLFxuICAgIGdldFRocmVhZCxcbiAgICBjcmVhdGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudDogZGVsZXRlQ29tbWVudDIsXG4gICAgYWRkUmVhY3Rpb246IGFkZFJlYWN0aW9uMixcbiAgICByZW1vdmVSZWFjdGlvbjogcmVtb3ZlUmVhY3Rpb24yXG4gIH07XG59XG52YXIgTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkyID0gNTA7XG5mdW5jdGlvbiBjcmVhdGVSb29tKG9wdGlvbnMsIGNvbmZpZykge1xuICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsUHJlc2VuY2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlKGNvbmZpZy5yb29tSWQpIDogb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UoY29uZmlnLnJvb21JZCkgOiBvcHRpb25zLmluaXRpYWxTdG9yYWdlO1xuICBjb25zdCBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuaW5zdGFsbEJnVGFiU3B5XSA9IGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCk7XG4gIGNvbnN0IGRlbGVnYXRlcyA9IHtcbiAgICAuLi5jb25maWcuZGVsZWdhdGVzLFxuICAgIC8vIEEgY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIGdvIGludG8gXCJ6b21iaWUgc3RhdGVcIiBvbmx5IGlmIGFsbCBvZiB0aGVcbiAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcHBseTpcbiAgICAvL1xuICAgIC8vIC0gVGhlIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgY2xpZW50IG9wdGlvbiBpcyBjb25maWd1cmVkXG4gICAgLy8gLSBUaGUgYnJvd3NlciB3aW5kb3cgaGFzIGJlZW4gaW4gdGhlIGJhY2tncm91bmQgZm9yIGF0IGxlYXN0XG4gICAgLy8gICBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIG1pbGxpc2Vjb25kc1xuICAgIC8vIC0gVGhlcmUgYXJlIG5vIHBlbmRpbmcgY2hhbmdlc1xuICAgIC8vXG4gICAgY2FuWm9tYmllKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAhPT0gdm9pZCAwICYmIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgIT09IG51bGwgJiYgRGF0ZS5ub3coKSA+IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgKyBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgJiYgZ2V0U3RvcmFnZVN0YXR1cygpICE9PSBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1hbmFnZWRTb2NrZXQgPSBuZXcgTWFuYWdlZFNvY2tldChcbiAgICBkZWxlZ2F0ZXMsXG4gICAgY29uZmlnLmVuYWJsZURlYnVnTG9nZ2luZ1xuICApO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGJ1ZmZlcjoge1xuICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICBsYXN0Rmx1c2hlZEF0OiAwLFxuICAgICAgcHJlc2VuY2VVcGRhdGVzOiAoXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBpbml0aWFsIHByZXNlbmNlIG1lc3NhZ2UgYXMgYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZVxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgZGF0YTogaW5pdGlhbFByZXNlbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBzdG9yYWdlT3BlcmF0aW9uczogW11cbiAgICB9LFxuICAgIHN0YXRpY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgZHluYW1pY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVJlZihpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE90aGVyc1JlZigpLFxuICAgIGluaXRpYWxTdG9yYWdlLFxuICAgIGlkRmFjdG9yeTogbnVsbCxcbiAgICAvLyBTdG9yYWdlXG4gICAgY2xvY2s6IDAsXG4gICAgb3BDbG9jazogMCxcbiAgICBub2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGRvTm90QmF0Y2hVcGRhdGVzID0gKGNiKSA9PiBjYigpO1xuICBjb25zdCBiYXRjaFVwZGF0ZXMgPSBjb25maWcudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPz8gZG9Ob3RCYXRjaFVwZGF0ZXM7XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgYWN0aXZlQmF0Y2gub3BzLnB1c2goLi4ub3BzKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBjb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBPbGQvZGVwcmVjYXRlZCBBUElcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbihcbiAgICAgIGNvbmZpZy5iYXNlVXJsLFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCl9JHtlbmRwb2ludH1gLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgXCIvc3RvcmFnZVwiLCBhdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBodHRwUG9zdFRvUm9vbShlbmRwb2ludCwgYm9keSkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoY29uZmlnLnJvb21JZCwgZW5kcG9pbnQsIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyk7XG4gICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5ub25jZTtcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQICYmIG5vbmNlKSB7XG4gICAgICBjb25zdCBzaXplID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRQYXlsb2FkKS5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIHZvaWQgaHR0cFBvc3RUb1Jvb20oXCIvc2VuZC1tZXNzYWdlXCIsIHsgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWVzc2FnZSB3YXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzIGFuZCBzZW50IG92ZXIgSFRUUCBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkU29ja2V0LnNlbmQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKSxcbiAgICAgICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGVcbiAgICAgICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuY3VycmVudDtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgfSk7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIHBvb2wpO1xuICAgIH1cbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IHN0YWNrU2l6ZUJlZm9yZTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb290KGl0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5ub2Rlcykge1xuICAgICAgY3VycmVudEl0ZW1zLnNldChpZCwgbm9kZS5fc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3IE1hcChpdGVtcykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgZmFsc2UpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5LnVuc2hpZnQoLi4uaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gdXBkYXRlcy5zdG9yYWdlVXBkYXRlcztcbiAgICBjb25zdCBvdGhlcnNVcGRhdGVzID0gdXBkYXRlcy5vdGhlcnM7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICAgIGV2ZW50SHViLm90aGVycy5ub3RpZnkoeyAuLi5ldmVudCwgb3RoZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcy5wcmVzZW5jZSA/PyBmYWxzZSkge1xuICAgICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGV2ZW50SHViLm15UHJlc2VuY2Uubm90aWZ5KGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlVXBkYXRlcyAhPT0gdm9pZCAwICYmIHN0b3JhZ2VVcGRhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICAgIGV2ZW50SHViLnN0b3JhZ2Uubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBbXSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KHJldmVyc2UpO1xuICAgICAgICBvdXRwdXQucHJlc2VuY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgICBzb3VyY2UgPSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcElkID0gbm4ob3Aub3BJZCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5kZWxldGUob3BJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICBzb3VyY2UgPSBkZWxldGVkID8gMiAvKiBBQ0sgKi8gOiAxIC8qIFJFTU9URSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseU9wUmVzdWx0ID0gYXBwbHlPcChvcCwgc291cmNlKTtcbiAgICAgICAgaWYgKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBub2RlSWQgPSBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkO1xuICAgICAgICAgIGlmICghKG5vZGVJZCAmJiBjcmVhdGVkTm9kZUlkcy5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpLFxuICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5nZXQobm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCkpLFxuICAgICAgICAgICAgICAgIGFwcGx5T3BSZXN1bHQubW9kaWZpZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQoLi4uYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBvdXRwdXQucmV2ZXJzZSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiBvbGRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMucHJlc2VuY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhcbiAgICAgICAgICAgIFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dLFxuICAgICAgICAgICAgZG9Ob3RCYXRjaFVwZGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICBhY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxuICAgICAgc2NvcGVzOiBtZXNzYWdlLnNjb3Blc1xuICAgIH0pO1xuICAgIGNvbnRleHQuaWRGYWN0b3J5ID0gbWFrZUlkRmFjdG9yeShtZXNzYWdlLmFjdG9yKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbklkIG9mIGNvbnRleHQub3RoZXJzLmNvbm5lY3Rpb25JZHMoKSkge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNbY29ubmVjdGlvbklkXTtcbiAgICAgIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1trZXldO1xuICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gTnVtYmVyKGtleSk7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIHVzZXIuaW5mbyxcbiAgICAgICAgdXNlci5zY29wZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVzZXRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVuZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgdGFyZ2V0QWN0b3I6IG1lc3NhZ2UuYWN0b3JcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIHJldHVybiB1c2VyID8geyB0eXBlOiBcImVudGVyXCIsIHVzZXIgfSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghaXNKc29uT2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlcyh0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHRyeVBhcnNlSnNvbih0ZXh0KTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzSnNvbkFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gY29tcGFjdChkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VTZXJ2ZXJNZXNzYWdlKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYWN0KFtwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlBbmRTZW5kT3BzKG9mZmxpbmVPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBBcnJheS5mcm9tKG9mZmxpbmVPcHMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyc2VTZXJ2ZXJNZXNzYWdlcyhldmVudC5kYXRhKTtcbiAgICBpZiAobWVzc2FnZXMgPT09IG51bGwgfHwgbWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG90aGVyczogW11cbiAgICB9O1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodXNlckpvaW5lZFVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzUHJlc2VuY2VVcGRhdGUgPSBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMyAvKiBCUk9BRENBU1RFRF9FVkVOVCAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgICAgIGV2ZW50SHViLmN1c3RvbUV2ZW50Lm5vdGlmeSh7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgICBldmVudDogbWVzc2FnZS5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChldmVudDIpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwNCAvKiBST09NX1NUQVRFICovOiB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLzoge1xuICAgICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcHBseVJlc3VsdC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksIHZhbHVlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgICAgXCJTdG9yYWdlIG11dGF0aW9uIHJlamVjdGlvbiBlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9IGNvbnRleHQub3BTdGFja1RyYWNlcz8uZ2V0KG9wSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB3YXJuV2l0aFRpdGxlKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBTdG9yYWdlIG11dGF0aW9ucyByZWplY3RlZCBieSBzZXJ2ZXI6ICR7bWVzc2FnZS5yZWFzb259YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA1IC8qIENPTU1FTlRfUkVBQ1RJT05fQURERUQgKi86XG4gICAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMyAvKiBDT01NRU5UX0VESVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90aWZ5KHVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaE5vd09yU29vbigpIHtcbiAgICBjb25zdCBzdG9yYWdlT3BzID0gY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnM7XG4gICAgaWYgKHN0b3JhZ2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBzdG9yYWdlT3BzKSB7XG4gICAgICAgIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2V0KG5uKG9wLm9wSWQpLCBvcCk7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRNaWxsaXMgPSBub3cgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdLFxuICAgICAgICBwcmVzZW5jZVVwZGF0ZXM6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICAgICAgY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEID0gc2V0VGltZW91dChcbiAgICAgICAgZmx1c2hOb3dPclNvb24sXG4gICAgICAgIGNvbmZpZy50aHJvdHRsZURlbGF5IC0gZWxhcHNlZE1pbGxpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLnR5cGUgPT09IFwiZnVsbFwiID8ge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgLy8gUG9wdWxhdGluZyB0aGUgYHRhcmdldEFjdG9yYCBmaWVsZCB0dXJucyB0aGlzIG1lc3NhZ2UgaW50b1xuICAgICAgICAgIC8vIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGUgbWVzc2FnZSAobm90IGEgcGF0Y2gpLCB3aGljaCB3aWxsIGdldFxuICAgICAgICAgIC8vIGludGVycHJldGVkIGJ5IG90aGVyIGNsaWVudHMgYXMgc3VjaC5cbiAgICAgICAgICB0YXJnZXRBY3RvcjogLTEsXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5idWZmZXIubWVzc2FnZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgICAgb3BzOiBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVZRG9jKHVwZGF0ZSwgZ3VpZCkge1xuICAgIGNvbnN0IGNsaWVudE1zZyA9IHtcbiAgICAgIHR5cGU6IDMwMSAvKiBVUERBVEVfWURPQyAqLyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIGd1aWRcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKC4uLm9wcyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBsZXQgX2dldFN0b3JhZ2UkID0gbnVsbDtcbiAgbGV0IF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BzID0gbmV3IE1hcChjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1GZXRjaChtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSwgY29uZmlnLnJvb21JZCk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQub3RoZXJzLFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyLCBpbmRleCkgPT4gdXNlclRvVHJlZU5vZGUoYE90aGVyICR7aW5kZXh9YCwgb3RoZXIpKVxuICApO1xuICBjb25zdCBldmVudHMgPSB7XG4gICAgc3RhdHVzOiBldmVudEh1Yi5zdGF0dXMub2JzZXJ2YWJsZSxcbiAgICBsb3N0Q29ubmVjdGlvbjogZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ub2JzZXJ2YWJsZSxcbiAgICBjdXN0b21FdmVudDogZXZlbnRIdWIuY3VzdG9tRXZlbnQub2JzZXJ2YWJsZSxcbiAgICBvdGhlcnM6IGV2ZW50SHViLm90aGVycy5vYnNlcnZhYmxlLFxuICAgIHNlbGY6IGV2ZW50SHViLnNlbGYub2JzZXJ2YWJsZSxcbiAgICBteVByZXNlbmNlOiBldmVudEh1Yi5teVByZXNlbmNlLm9ic2VydmFibGUsXG4gICAgZXJyb3I6IGV2ZW50SHViLmVycm9yLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZTogZXZlbnRIdWIuc3RvcmFnZS5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGNvbnN0IGNvbW1lbnRzQXBpID0gY3JlYXRlQ29tbWVudHNBcGkoXG4gICAgY29uZmlnLnJvb21JZCxcbiAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlLFxuICAgIGZldGNoQ2xpZW50QXBpXG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoTm90aWZpY2F0aW9uc0pzb24oZW5kcG9pbnQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDbGllbnRBcGkoXG4gICAgICBjb25maWcucm9vbUlkLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICBvcHRpb25zMlxuICAgICk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIGxldCBlcnJvcjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBOb3RpZmljYXRpb25zQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBOb3RpZmljYXRpb25zQXBpRXJyb3IoXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICBcIi9ub3RpZmljYXRpb24tc2V0dGluZ3NcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICBcIi9ub3RpZmljYXRpb24tc2V0dGluZ3NcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoTm90aWZpY2F0aW9uc0pzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgIGF3YWl0IG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpO1xuICAgICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uSWRzO1xuICAgIH0sXG4gICAgeyBkZWxheTogTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkyIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgdGhlIExpdmVibG9ja3MgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgZ2V0U2VsZl9mb3JEZXZUb29sczogKCkgPT4gc2VsZkFzVHJlZU5vZGUuY3VycmVudCxcbiAgICAgICAgZ2V0T3RoZXJzX2ZvckRldlRvb2xzOiAoKSA9PiBvdGhlcnNfZm9yRGV2VG9vbHMuY3VycmVudCxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHNpbXVsYXRlOiB7XG4gICAgICAgICAgLy8gVGhlc2UgZXhpc3Qgb25seSBmb3Igb3VyIEUyRSB0ZXN0aW5nIGFwcFxuICAgICAgICAgIGV4cGxpY2l0Q2xvc2U6IChldmVudCkgPT4gbWFuYWdlZFNvY2tldC5fcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KSxcbiAgICAgICAgICByYXdTZW5kOiAoZGF0YSkgPT4gbWFuYWdlZFNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnRzOiB7XG4gICAgICAgICAgLi4uY29tbWVudHNBcGlcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIGdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpZDogY29uZmlnLnJvb21JZCxcbiAgICAgIHN1YnNjcmliZTogbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgdW5pbnN0YWxsQmdUYWJTcHkoKTtcbiAgICAgICAgbWFuYWdlZFNvY2tldC5kZXN0cm95KCk7XG4gICAgICB9LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgdXBkYXRlWURvYyxcbiAgICAgIGJyb2FkY2FzdEV2ZW50LFxuICAgICAgLy8gU3RvcmFnZVxuICAgICAgYmF0Y2gsXG4gICAgICBoaXN0b3J5OiB7XG4gICAgICAgIHVuZG8sXG4gICAgICAgIHJlZG8sXG4gICAgICAgIGNhblVuZG8sXG4gICAgICAgIGNhblJlZG8sXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBwYXVzZTogcGF1c2VIaXN0b3J5LFxuICAgICAgICByZXN1bWU6IHJlc3VtZUhpc3RvcnlcbiAgICAgIH0sXG4gICAgICBmZXRjaFlEb2MsXG4gICAgICBnZXRTdG9yYWdlLFxuICAgICAgZ2V0U3RvcmFnZVNuYXBzaG90LFxuICAgICAgZ2V0U3RvcmFnZVN0YXR1cyxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldENvbm5lY3Rpb25TdGF0ZTogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRMZWdhY3lTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuY3VycmVudCxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICBnZXRQcmVzZW5jZTogKCkgPT4gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmN1cnJlbnRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgICBpZiAodXBkYXRlLm5vZGUuX2lkID09PSBub2RlLl9pZCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVwZGF0ZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmaXJzdCwgc2Vjb25kLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1Jvb21FdmVudE5hbWUoZmlyc3QpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHNlY29uZDtcbiAgICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJteS1wcmVzZW5jZVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwib3RoZXJzXCI6IHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3RoZXJzLCAuLi5pbnRlcm5hbEV2ZW50IH0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiBjYihvdGhlcnMsIGludGVybmFsRXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuZXJyb3Iuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImNvbm5lY3Rpb25cIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHN0YXR1cykgPT4gY2IobmV3VG9MZWdhY3lTdGF0dXMoc3RhdHVzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybC50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL3N0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgdGhyZWFkczoge30sXG4gICAgcXVlcmllczoge30sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFtdLFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge30sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHt9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLnN0b3JlLFxuICAgIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRocmVhZHM6IGRlbGV0ZUtleUltbXV0YWJsZShzdGF0ZS50aHJlYWRzLCB0aHJlYWRJZCksXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbHRlcihcbiAgICAgICAgICAgICAgKFtfaWQsIG5vdGlmaWNhdGlvbl0pID0+IG5vdGlmaWNhdGlvbi50aHJlYWRJZCAhPT0gdGhyZWFkSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWQuaWRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRocmVhZHM6IGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDAgfHwgY29tcGFyZVRocmVhZHModGhyZWFkLCBleGlzdGluZ1RocmVhZCkgPT09IDEgPyB7IC4uLnN0YXRlLnRocmVhZHMsIFt0aHJlYWQuaWRdOiB0aHJlYWQgfSA6IHN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwID8gc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zIDoge1xuICAgICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uLmlkXTogaW5ib3hOb3RpZmljYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKHRocmVhZHMsIGluYm94Tm90aWZpY2F0aW9ucywgZGVsZXRlZFRocmVhZHMsIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsIHF1ZXJ5S2V5KSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdGhyZWFkczogYXBwbHlUaHJlYWRVcGRhdGVzKHN0YXRlLnRocmVhZHMsIHtcbiAgICAgICAgICBuZXdUaHJlYWRzOiB0aHJlYWRzLFxuICAgICAgICAgIGRlbGV0ZWRUaHJlYWRzXG4gICAgICAgIH0pLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoXG4gICAgICAgICAgc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5ld0luYm94Tm90aWZpY2F0aW9uczogaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgZGVsZXRlZE5vdGlmaWNhdGlvbnM6IGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHF1ZXJpZXM6IHF1ZXJ5S2V5ICE9PSB2b2lkIDAgPyB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IDogc3RhdGUucXVlcmllc1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgdXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgICAgIC4uLnN0YXRlLm5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIFtyb29tSWRdOiBzZXR0aW5nc1xuICAgICAgICB9LFxuICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBwdXNoT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFsuLi5zdGF0ZS5vcHRpbWlzdGljVXBkYXRlcywgb3B0aW1pc3RpY1VwZGF0ZV1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHNldFF1ZXJ5U3RhdGUocXVlcnlLZXksIHF1ZXJ5U3RhdGUpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiBxdWVyeVN0YXRlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVLZXlJbW11dGFibGUocmVjb3JkLCBrZXkpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNvcmQsIGtleSkpIHtcbiAgICBjb25zdCB7IFtrZXldOiBfdG9EZWxldGUsIC4uLnJlc3QgfSA9IHJlY29yZDtcbiAgICByZXR1cm4gcmVzdDtcbiAgfVxuICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gY29tcGFyZVRocmVhZHModGhyZWFkMSwgdGhyZWFkMikge1xuICBpZiAodGhyZWFkMS51cGRhdGVkQXQgJiYgdGhyZWFkMi51cGRhdGVkQXQpIHtcbiAgICByZXR1cm4gdGhyZWFkMS51cGRhdGVkQXQgPiB0aHJlYWQyLnVwZGF0ZWRBdCA/IDEgOiB0aHJlYWQxLnVwZGF0ZWRBdCA8IHRocmVhZDIudXBkYXRlZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKHRocmVhZDEudXBkYXRlZEF0IHx8IHRocmVhZDIudXBkYXRlZEF0KSB7XG4gICAgcmV0dXJuIHRocmVhZDEudXBkYXRlZEF0ID8gMSA6IC0xO1xuICB9XG4gIGlmICh0aHJlYWQxLmNyZWF0ZWRBdCA+IHRocmVhZDIuY3JlYXRlZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodGhyZWFkMS5jcmVhdGVkQXQgPCB0aHJlYWQyLmNyZWF0ZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMoc3RhdGUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHRocmVhZHM6IHtcbiAgICAgIC4uLnN0YXRlLnRocmVhZHNcbiAgICB9LFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgfSxcbiAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgLi4uc3RhdGUubm90aWZpY2F0aW9uU2V0dGluZ3NcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZSBvZiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcykge1xuICAgIHN3aXRjaCAob3B0aW1pc3RpY1VwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiY3JlYXRlLXRocmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkLmlkXSA9IG9wdGltaXN0aWNVcGRhdGUudGhyZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC51cGRhdGVkQXQgIT09IHZvaWQgMCAmJiB0aHJlYWQudXBkYXRlZEF0ID4gb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0ge1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLm1ldGFkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gdXBzZXJ0Q29tbWVudChcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBkZWxldGVDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhZGQtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IGFkZFJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlbW92ZS1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gcmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZW1vamksXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZW1vdmVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSA9IHtcbiAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSxcbiAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1tpZF0gPSB7XG4gICAgICAgICAgICAuLi5yZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2lkXSxcbiAgICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICByZXN1bHQubm90aWZpY2F0aW9uU2V0dGluZ3Nbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdID0ge1xuICAgICAgICAgIC4uLnJlc3VsdC5ub3RpZmljYXRpb25TZXR0aW5nc1tvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0sXG4gICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5zZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXBwbHlUaHJlYWRVcGRhdGVzKGV4aXN0aW5nVGhyZWFkcywgdXBkYXRlcykge1xuICBjb25zdCB1cGRhdGVkVGhyZWFkcyA9IHsgLi4uZXhpc3RpbmdUaHJlYWRzIH07XG4gIHVwZGF0ZXMubmV3VGhyZWFkcy5mb3JFYWNoKCh0aHJlYWQpID0+IHtcbiAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHVwZGF0ZWRUaHJlYWRzW3RocmVhZC5pZF07XG4gICAgaWYgKGV4aXN0aW5nVGhyZWFkKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlVGhyZWFkcyhleGlzdGluZ1RocmVhZCwgdGhyZWFkKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZFRocmVhZHNbdGhyZWFkLmlkXSA9IHRocmVhZDtcbiAgfSk7XG4gIHVwZGF0ZXMuZGVsZXRlZFRocmVhZHMuZm9yRWFjaCgoeyBpZCwgZGVsZXRlZEF0IH0pID0+IHtcbiAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHVwZGF0ZWRUaHJlYWRzW2lkXTtcbiAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBleGlzdGluZ1RocmVhZC5kZWxldGVkQXQgPSBkZWxldGVkQXQ7XG4gICAgZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLmNvbW1lbnRzID0gW107XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZFRocmVhZHM7XG59XG5mdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSB7IC4uLmV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zIH07XG4gIHVwZGF0ZXMubmV3SW5ib3hOb3RpZmljYXRpb25zLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdO1xuICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gbm90aWZpY2F0aW9uO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkTm90aWZpY2F0aW9ucy5mb3JFYWNoKFxuICAgICh7IGlkIH0pID0+IGRlbGV0ZSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW2lkXVxuICApO1xuICByZXR1cm4gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB1cHNlcnRDb21tZW50KHRocmVhZCwgY29tbWVudCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoY29tbWVudC50aHJlYWRJZCAhPT0gdGhyZWFkLmlkKSB7XG4gICAgd2FybihcbiAgICAgIGBDb21tZW50ICR7Y29tbWVudC5pZH0gZG9lcyBub3QgYmVsb25nIHRvIHRocmVhZCAke3RocmVhZC5pZH1gXG4gICAgKTtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgodGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDAsIGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQsXG4gICAgICBjb21tZW50czogWy4uLnRocmVhZC5jb21tZW50cywgY29tbWVudF1cbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBjb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0IDw9IGNvbW1lbnQuZWRpdGVkQXQpIHtcbiAgICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWQgPyBjb21tZW50IDogZXhpc3RpbmdDb21tZW50MlxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwLFxuICAgICAgICAgIGNvbW1lbnQuZWRpdGVkQXQ/LmdldFRpbWUoKSB8fCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIHJldHVybiB0aHJlYWQ7XG59XG5mdW5jdGlvbiBkZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICBib2R5OiB2b2lkIDBcbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAoIXVwZGF0ZWRDb21tZW50cy5zb21lKChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCA9PT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYWRkUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIHJlYWN0aW9uKSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgcmVhY3Rpb25zOiB1cHNlcnRSZWFjdGlvbihjb21tZW50LnJlYWN0aW9ucywgcmVhY3Rpb24pXG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlYWN0aW9uLmNyZWF0ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICB1c2VyczogcmVhY3Rpb24udXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWQpXG4gICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgKS5maWx0ZXIoKHJlYWN0aW9uKSA9PiByZWFjdGlvbi51c2Vycy5sZW5ndGggPiAwKVxuICAgICAgLy8gUmVtb3ZlIHJlYWN0aW9ucyB3aXRoIG5vIHVzZXJzIGxlZnRcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVtb3ZlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDApXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiB1cHNlcnRSZWFjdGlvbihyZWFjdGlvbnMsIHJlYWN0aW9uKSB7XG4gIGNvbnN0IGV4aXN0aW5nUmVhY3Rpb24gPSByZWFjdGlvbnMuZmluZChcbiAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaVxuICApO1xuICBpZiAoZXhpc3RpbmdSZWFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnJlYWN0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICBjcmVhdGVkQXQ6IHJlYWN0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcnM6IFt7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXIpID0+IHVzZXIuaWQgPT09IHJlYWN0aW9uLnVzZXJJZCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9ucy5tYXAoXG4gICAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaSA/IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSZWFjdGlvbjIsXG4gICAgICAgIHVzZXJzOiBbLi4uZXhpc3RpbmdSZWFjdGlvbjIudXNlcnMsIHsgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfSA6IGV4aXN0aW5nUmVhY3Rpb24yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVhY3Rpb25zO1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xudmFyIFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgPSA1MDtcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpIHtcbiAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNsaWVudE9wdGlvbnMuYmFzZVVybCk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucyk7XG4gIGNvbnN0IHJvb21zQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duUm9vbShyb29tKSB7XG4gICAgdW5saW5rRGV2VG9vbHMocm9vbS5pZCk7XG4gICAgcm9vbXNCeUlkLmRlbGV0ZShyb29tLmlkKTtcbiAgICByb29tLmRlc3Ryb3koKTtcbiAgfVxuICBmdW5jdGlvbiBsZWFzZVJvb20oaW5mbykge1xuICAgIGNvbnN0IGxlYXZlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGxlYXZlO1xuICAgICAgaWYgKCFpbmZvLnVuc3Vicy5kZWxldGUoc2VsZikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIlRoaXMgbGVhdmUgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkLiBDYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGhhcyBubyBlZmZlY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLnVuc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGVhcmRvd25Sb29tKGluZm8ucm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluZm8udW5zdWJzLmFkZChsZWF2ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IGluZm8ucm9vbSxcbiAgICAgIGxlYXZlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgZGVwcmVjYXRlSWYoXG4gICAgICBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IG51bGwgfHwgb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSB2b2lkIDAsXG4gICAgICBcIlBsZWFzZSBwcm92aWRlIGFuIGluaXRpYWwgcHJlc2VuY2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHVzZXIgd2hlbiBlbnRlcmluZyB0aGUgcm9vbS5cIlxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbSA9IGNyZWF0ZVJvb20oXG4gICAgICB7XG4gICAgICAgIGluaXRpYWxQcmVzZW5jZTogb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID8/IHt9LFxuICAgICAgICBpbml0aWFsU3RvcmFnZTogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21JbmZvID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21JbmZvKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyBvcHRpb25zMi5zaG91bGRJbml0aWFsbHlDb25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbUluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyKHJvb21JZCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCB7IHJvb20sIGxlYXZlOiBfIH0gPSBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMik7XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZm9yY2VMZWF2ZShyb29tSWQpIHtcbiAgICBjb25zdCB1bnN1YnMgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnVuc3VicyA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY3JlYXRlU3RvcmUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgfSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hlcjogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmV0Y2gsXG4gICAgYXV0aE1hbmFnZXIsXG4gICAgY3VycmVudFVzZXJJZFN0b3JlXG4gIH0pO1xuICBjb25zdCBjYWNoZVN0b3JlID0gY3JlYXRlQ2xpZW50U3RvcmUoKTtcbiAgY29uc3QgcmVzb2x2ZVVzZXJzID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlVXNlcnM7XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVVzZXJzID0gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKFxuICAgICgpID0+ICFyZXNvbHZlVXNlcnMsXG4gICAgXCJTZXQgdGhlIHJlc29sdmVVc2VycyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgdXNlciBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGxvZ291dCxcbiAgICAgIC8vIE9sZCwgZGVwcmVjYXRlZCBBUElzXG4gICAgICBlbnRlcixcbiAgICAgIGdldFJvb20sXG4gICAgICBsZWF2ZTogZm9yY2VMZWF2ZSxcbiAgICAgIC8vIE5ldywgcHJlZmVycmVkIEFQSVxuICAgICAgZW50ZXJSb29tLFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudFVzZXJJZFN0b3JlLFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiBjbGllbnRPcHRpb25zLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gICAgICAgIGNhY2hlU3RvcmUsXG4gICAgICAgIHVzZXJzU3RvcmUsXG4gICAgICAgIHJvb21zSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG52YXIgTm90aWZpY2F0aW9uc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwiYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFRocm90dGxlKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcInRocm90dGxlXCIsIHZhbHVlLCBNSU5fVEhST1RUTEUsIE1BWF9USFJPVFRMRSk7XG59XG5mdW5jdGlvbiBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwibG9zdENvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhjb25kaXRpb24sIC4uLmFyZ3MpIHtcbiAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghaGFzV2FybmVkICYmICh0eXBlb2YgY29uZGl0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBjb25kaXRpb24oKSA6IGNvbmRpdGlvbikpIHtcbiAgICAgICAgd2FybiguLi5hcmdzKTtcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC1ib2R5LnRzXG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudXJsLFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPHNwYW4gZGF0YS1tZW50aW9uPkAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH08L3NwYW4+YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmAqKiR7Y2hpbGRyZW59KipgO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXyR7Y2hpbGRyZW59X2A7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gfn4ke2NoaWxkcmVufX5+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBcXGAke2NoaWxkcmVufVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYFske2VsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2spIHtcbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZShjb250ZXh0LmludGVydmFsKTtcbiAgICB9XG4gICAgdm9pZCBjYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGludGVydmFsKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LnN0YXRlICE9PSBcInN0b3BwZWRcIiA/IGNvbnRleHQuaW50ZXJ2YWwgOiBpbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZVJlbWFpbmluZyhyZW1haW5pbmcpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCByZW1haW5pbmcpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KGludGVydmFsKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KGludGVydmFsKSB7XG4gICAgc3RvcCgpO1xuICAgIHN0YXJ0KGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInBhdXNlZFwiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBjb250ZXh0LmludGVydmFsIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U2NoZWR1bGVkQXQpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1haW5pbmcoY29udGV4dC5yZW1haW5pbmdJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgICBpbnRlcnZhbDogbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXN0YXJ0LFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakIpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgV2Vic29ja2V0Q2xvc2VDb2RlcyxcbiAgYWNrT3AsXG4gIGFkZFJlYWN0aW9uLFxuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYjY0ZGVjb2RlLFxuICBjbG9uZUxzb24sXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlQ2xpZW50LFxuICBkZWxldGVDb21tZW50LFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGtJbnRlcm5hbCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbm4sXG4gIHBhdGNoTGl2ZU9iamVjdEtleSxcbiAgcmFpc2UsXG4gIHJlbW92ZVJlYWN0aW9uLFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHVwc2VydENvbW1lbnQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   shallow: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n/* harmony export */   useLiveblocksContextBundle: () => (/* binding */ useLiveblocksContextBundle),\n/* harmony export */   useRoomContextBundle: () => (/* binding */ useRoomContextBundle),\n/* harmony export */   useSharedContextBundle: () => (/* binding */ useSharedContextBundle)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createLiveblocksContext,createRoomContext,shallow,useLiveblocksContextBundle,useRoomContextBundle,useSharedContextBundle auto */ // src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.11.0\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n// src/liveblocks.tsx\n\n\n\n\n\n// src/comments/lib/selected-inbox-notifications.ts\n\nfunction selectedInboxNotifications(state) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return Object.values(result.inboxNotifications).sort(// Sort so that the most recent notifications are first\n    (a, b)=>b.notifiedAt.getTime() - a.notifiedAt.getTime());\n}\n// src/lib/retry-error.ts\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n    if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n    const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n    setTimeout(()=>{\n        void action();\n    }, timeout);\n}\n// src/shared.ts\n\n\n\n// src/room.tsx\n\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n    constructor(cause, context){\n        super(\"Mark inbox notification as read failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"MarkInboxNotificationAsReadError\";\n    }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n    constructor(cause, context){\n        super(\"Update notification settings failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"UpdateNotificationSettingsError\";\n    }\n};\n// src/comments/lib/createIds.ts\n\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nfunction createOptimisticId(prefix) {\n    return `${prefix}_${(0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)()}`;\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\n// src/comments/lib/select-notification-settings.ts\n\nfunction selectNotificationSettings(roomId, state) {\n    const { notificationSettings } = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(notificationSettings[roomId]);\n}\n// src/comments/lib/selected-threads.ts\n\nfunction selectedThreads(roomId, state, options) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    const threads = Object.values(result.threads).filter((thread)=>{\n        if (thread.roomId !== roomId) return false;\n        if (thread.deletedAt !== void 0) {\n            return false;\n        }\n        const query = options.query;\n        if (!query) return true;\n        for(const key in query.metadata){\n            if (thread.metadata[key] !== query.metadata[key]) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return threads.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n}\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n// src/room.tsx\nvar noop = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>`We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(roomId)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\nfunction useSyncExternalStore(s, gs, gss) {\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL = 5 * 60 * 1e3;\nvar MENTION_SUGGESTIONS_DEBOUNCE = 500;\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nfunction createRoomContext(client, options) {\n    if (options?.resolveUsers) {\n        throw new Error(\"The 'resolveUsers' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    if (options?.resolveMentionSuggestions) {\n        throw new Error(\"The 'resolveMentionSuggestions' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const shared = createSharedContext(client);\n    function RoomProviderOuter(props) {\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    function RoomProviderInner(props) {\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? \"undefined\" !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            async function handleCommentEvent(message) {\n                const info = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThread({\n                    threadId: message.threadId\n                });\n                if (!info) {\n                    store.deleteThread(message.threadId);\n                    return;\n                }\n                const { thread, inboxNotification } = info;\n                const existingThread = store.get().threads[message.threadId];\n                switch(message.type){\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n                        if (!existingThread) break;\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            return room.events.comments.subscribe((message)=>void handleCommentEvent(message));\n        }, [\n            room\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsUpdates(room.id);\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            function handleIsOnline() {\n                void getThreadsUpdates(room.id);\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: bundle\n        }, props.children));\n    }\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    function useStatus() {\n        const room = useRoom();\n        const subscribe = room.events.status.subscribe;\n        const getSnapshot = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    function useMyPresence() {\n        const room = useRoom();\n        const subscribe = room.events.myPresence.subscribe;\n        const getSnapshot = room.getPresence;\n        const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    function useUpdateMyPresence() {\n        return useRoom().updatePresence;\n    }\n    function useOthers(selector, isEqual) {\n        const room = useRoom();\n        const subscribe = room.events.others.subscribe;\n        const getSnapshot = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, selector ?? identity, isEqual);\n    }\n    function useOthersConnectionIds() {\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual ?? Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual ?? Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(`No such other user with connection id ${connectionId} exists`);\n        }\n        return other;\n    }\n    function useBroadcastEvent() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event, options2 = {\n            shouldQueueEventIfNotReady: false\n        })=>{\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    function useOthersListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useLostConnectionListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useErrorListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useEventListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    function useSelf(maybeSelector, isEqual) {\n        const room = useRoom();\n        const subscribe = room.events.self.subscribe;\n        const getSnapshot = room.getSelf;\n        const selector = maybeSelector ?? identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function useMutableStorageRoot() {\n        const room = useRoom();\n        const subscribe = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    function useStorageRoot() {\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    function useHistory() {\n        return useRoom().history;\n    }\n    function useUndo() {\n        return useHistory().undo;\n    }\n    function useRedo() {\n        return useHistory().redo;\n    }\n    function useCanUndo() {\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore(subscribe, canUndo, canUndo);\n    }\n    function useCanRedo() {\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore(subscribe, canRedo, canRedo);\n    }\n    function useBatch() {\n        return useRoom().batch;\n    }\n    function useLegacyKey(key) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr?.();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr?.();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    function useStorage(selector, isEqual) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function ensureNotServerSide() {\n        if (true) {\n            throw new Error(\"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\");\n        }\n    }\n    function useSuspendUntilStorageLoaded() {\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    function useSuspendUntilPresenceLoaded() {\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    function useMutation(callback, deps) {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args));\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    function useStorageSuspense(selector, isEqual) {\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    function useSelfSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    function useOthersSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    function useOthersConnectionIdsSuspense() {\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    function useLegacyKeySuspense(key) {\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n        store.set((state)=>({\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n            }));\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError) {\n            const error = handleApiError(innerError);\n            commentsErrorEventSource.notify(createPublicError(error));\n            return;\n        }\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.NotificationsApiError) {\n            handleApiError(innerError);\n            return;\n        }\n        throw innerError;\n    }\n    const subscribersByQuery = /* @__PURE__ */ new Map();\n    const requestsByQuery = /* @__PURE__ */ new Map();\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    async function refreshThreadsAndNotifications() {\n        const requests = [];\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getRoomIds().map((roomId)=>{\n            const room = client.getRoom(roomId);\n            if (room === null) return;\n            requests.push(getThreadsUpdates(room.id));\n        });\n        await Promise.allSettled(requests);\n    }\n    function incrementQuerySubscribers(queryKey) {\n        const subscribers = subscribersByQuery.get(queryKey) ?? 0;\n        subscribersByQuery.set(queryKey, subscribers + 1);\n        poller.start(POLLING_INTERVAL);\n    }\n    function decrementQuerySubscribers(queryKey) {\n        const subscribers = subscribersByQuery.get(queryKey);\n        if (subscribers === void 0 || subscribers <= 0) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot decrease subscriber count for query \"${queryKey}\"`);\n            return;\n        }\n        subscribersByQuery.set(queryKey, subscribers - 1);\n        let totalSubscribers = 0;\n        for (const subscribers2 of subscribersByQuery.values()){\n            totalSubscribers += subscribers2;\n        }\n        if (totalSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function getThreadsAndInboxNotifications(room, queryKey, options2, { retryCount } = {\n        retryCount: 0\n    }) {\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads(options2);\n        requestsByQuery.set(queryKey, request);\n        store.setQueryState(queryKey, {\n            isLoading: true\n        });\n        try {\n            const result = await request;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, queryKey);\n            const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n            }\n            poller.start(POLLING_INTERVAL);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getThreadsAndInboxNotifications(room, queryKey, options2, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    const DEFAULT_DEDUPING_INTERVAL = 2e3;\n    const lastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    const requestStatusByRoom = /* @__PURE__ */ new Map();\n    async function getThreadsUpdates(roomId) {\n        const room = client.getRoom(roomId);\n        if (room === null) return;\n        const since = lastRequestedAtByRoom.get(room.id);\n        if (since === void 0) return;\n        const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;\n        if (isFetchingThreadsUpdates === true) return;\n        try {\n            requestStatusByRoom.set(room.id, true);\n            const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads({\n                since\n            });\n            setTimeout(()=>{\n                requestStatusByRoom.set(room.id, false);\n            }, DEFAULT_DEDUPING_INTERVAL);\n            store.updateThreadsAndNotifications(updates.threads, updates.inboxNotifications, updates.deletedThreads, updates.deletedInboxNotifications);\n            lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n        } catch (err) {\n            requestStatusByRoom.set(room.id, false);\n            return;\n        }\n    }\n    function handleScrollToCommentOnLoad(isQueryLoading, shouldScrollOnLoad, state) {\n        if (shouldScrollOnLoad === false) return;\n        if (isQueryLoading === true) return;\n        const isWindowDefined = \"undefined\" !== \"undefined\";\n        if (!isWindowDefined) return;\n        const hash = window.location.hash;\n        const commentId = hash.slice(1);\n        if (!commentId.startsWith(\"cm_\")) return;\n        const comment = document.getElementById(commentId);\n        if (comment === null) return;\n        const comments = state.threads.flatMap((thread)=>thread.comments);\n        const isCommentInThreads = comments.some((comment2)=>comment2.id === commentId);\n        if (!isCommentInThreads) return;\n        comment.scrollIntoView();\n    }\n    function useThreads(options2 = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const { scrollOnLoad = true } = options2;\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2.query), [\n            room,\n            options2\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsAndInboxNotifications(room, queryKey, options2);\n            incrementQuerySubscribers(queryKey);\n            return ()=>decrementQuerySubscribers(queryKey);\n        }, [\n            room,\n            queryKey\n        ]);\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state2)=>{\n            const query = state2.queries[queryKey];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            return {\n                threads: selectedThreads(room.id, state2, options2),\n                isLoading: false,\n                error: query.error\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (state.isLoading === true) return;\n            handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n        [\n            state.isLoading\n        ]);\n        return state;\n    }\n    function useThreadsSuspense(options2 = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const { scrollOnLoad = true } = options2;\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2.query), [\n            room,\n            options2\n        ]);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getThreadsAndInboxNotifications(room, queryKey, options2);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state2)=>{\n            return {\n                threads: selectedThreads(room.id, state2, options2),\n                isLoading: false\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementQuerySubscribers(queryKey);\n            return ()=>{\n                decrementQuerySubscribers(queryKey);\n            };\n        }, [\n            queryKey\n        ]);\n        const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n        [\n            state.isLoading\n        ]);\n        return state;\n    }\n    function useCreateThread() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            const body = options2.body;\n            const metadata = \"metadata\" in options2 ? options2.metadata : {};\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt,\n                updatedAt: createdAt,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-thread\",\n                thread: newThread,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }).then((thread)=>{\n                store.set((state)=>({\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: thread\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateThreadError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body,\n                        metadata\n                    })));\n            return newThread;\n        }, [\n            room\n        ]);\n    }\n    function useEditThreadMetadata() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            if (!(\"metadata\" in options2)) {\n                return;\n            }\n            const threadId = options2.threadId;\n            const metadata = options2.metadata;\n            const updatedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"edit-thread-metadata\",\n                metadata,\n                id: optimisticUpdateId,\n                threadId,\n                updatedAt\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editThreadMetadata({\n                metadata,\n                threadId\n            }).then((metadata2)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.deletedAt !== void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: {\n                                ...existingThread,\n                                metadata: metadata2\n                            }\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditThreadMetadataError(error, {\n                        roomId: room.id,\n                        threadId,\n                        metadata\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useAddReaction() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, emoji })=>{\n            const createdAt = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"add-reaction\",\n                threadId,\n                commentId,\n                reaction: {\n                    emoji,\n                    userId,\n                    createdAt\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then((addedReaction)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.addReaction)(existingThread, commentId, addedReaction)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new AddReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useRemoveReaction() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, emoji })=>{\n            const userId = getCurrentUserId(room);\n            const removedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"remove-reaction\",\n                threadId,\n                commentId,\n                emoji,\n                userId,\n                removedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.removeReaction)(existingThread, commentId, emoji, userId, removedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new RemoveReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useCreateComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, body })=>{\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-comment\",\n                comment,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createComment({\n                threadId,\n                commentId,\n                body\n            }).then((newComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    const inboxNotification = Object.values(state.inboxNotifications).find((notification)=>notification.threadId === threadId);\n                    const updatedInboxNotifications = inboxNotification !== void 0 ? {\n                        ...state.inboxNotifications,\n                        [inboxNotification.id]: {\n                            ...inboxNotification,\n                            notifiedAt: newComment.createdAt,\n                            readAt: newComment.createdAt\n                        }\n                    } : state.inboxNotifications;\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, newComment)\n                        },\n                        inboxNotifications: updatedInboxNotifications,\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateCommentError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n            return comment;\n        }, [\n            room\n        ]);\n    }\n    function useEditComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, body })=>{\n            const editedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const thread = store.get().threads[threadId];\n            if (thread === void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`);\n                return;\n            }\n            const comment = thread.comments.find((comment2)=>comment2.id === commentId);\n            if (comment === void 0 || comment.deletedAt !== void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`);\n                return;\n            }\n            store.pushOptimisticUpdate({\n                type: \"edit-comment\",\n                comment: {\n                    ...comment,\n                    editedAt,\n                    body\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editComment({\n                threadId,\n                commentId,\n                body\n            }).then((editedComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, editedComment)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useDeleteComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId })=>{\n            const deletedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"delete-comment\",\n                threadId,\n                commentId,\n                deletedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.deleteComment({\n                threadId,\n                commentId\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deleteComment)(existingThread, commentId, deletedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new DeleteCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId\n                    })));\n        }, [\n            room\n        ]);\n    }\n    const resolveMentionSuggestions = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].resolveMentionSuggestions;\n    const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n    function useMentionSuggestions(search) {\n        const room = useRoom();\n        const [mentionSuggestions, setMentionSuggestions] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n        const lastInvokedAt = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (search === void 0 || !resolveMentionSuggestions) {\n                return;\n            }\n            const resolveMentionSuggestionsArgs = {\n                text: search,\n                roomId: room.id\n            };\n            const mentionSuggestionsCacheKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(resolveMentionSuggestionsArgs);\n            let debounceTimeout;\n            let isCanceled = false;\n            const getMentionSuggestions = async ()=>{\n                try {\n                    lastInvokedAt.current = performance.now();\n                    const mentionSuggestions2 = await resolveMentionSuggestions(resolveMentionSuggestionsArgs);\n                    if (!isCanceled) {\n                        setMentionSuggestions(mentionSuggestions2);\n                        mentionSuggestionsCache.set(mentionSuggestionsCacheKey, mentionSuggestions2);\n                    }\n                } catch (error) {\n                    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(error?.message);\n                }\n            };\n            if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n                setMentionSuggestions(mentionSuggestionsCache.get(mentionSuggestionsCacheKey));\n            } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {\n                void getMentionSuggestions();\n            } else {\n                debounceTimeout = window.setTimeout(()=>{\n                    void getMentionSuggestions();\n                }, MENTION_SUGGESTIONS_DEBOUNCE);\n            }\n            return ()=>{\n                isCanceled = true;\n                window.clearTimeout(debounceTimeout);\n            };\n        }, [\n            room.id,\n            search\n        ]);\n        return mentionSuggestions;\n    }\n    function useThreadSubscription(threadId) {\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const inboxNotification = selectedInboxNotifications(state).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            const thread = state.threads[threadId];\n            if (inboxNotification === void 0 || thread === void 0) {\n                return {\n                    status: \"not-subscribed\"\n                };\n            }\n            return {\n                status: \"subscribed\",\n                unreadSince: inboxNotification.readAt\n            };\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    function useMarkThreadAsRead() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((threadId)=>{\n            const inboxNotification = Object.values(store.get().inboxNotifications).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            if (!inboxNotification) return;\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const now = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId: inboxNotification.id,\n                readAt: now\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.markInboxNotificationAsRead(inboxNotification.id).then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotification.id]: {\n                                ...inboxNotification,\n                                readAt: now\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>{\n                onMutationFailure(err, optimisticUpdateId, (error)=>new MarkInboxNotificationAsReadError(error, {\n                        inboxNotificationId: inboxNotification.id\n                    }));\n                return;\n            });\n        }, [\n            room\n        ]);\n    }\n    function makeNotificationSettingsQueryKey(roomId) {\n        return `${roomId}:NOTIFICATION_SETTINGS`;\n    }\n    async function getInboxNotificationSettings(room, queryKey, { retryCount } = {\n        retryCount: 0\n    }) {\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        try {\n            const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.getRoomNotificationSettings();\n            requestsByQuery.set(queryKey, request);\n            store.setQueryState(queryKey, {\n                isLoading: true\n            });\n            const settings = await request;\n            store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getInboxNotificationSettings(room, queryKey, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    function useRoomNotificationSettings() {\n        const room = useRoom();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const queryKey = makeNotificationSettingsQueryKey(room.id);\n            void getInboxNotificationSettings(room, queryKey);\n        }, [\n            room\n        ]);\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            if (query.error !== void 0) {\n                return {\n                    isLoading: false,\n                    error: query.error\n                };\n            }\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    function useRoomNotificationSettingsSuspense() {\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const room = useRoom();\n        const queryKey = makeNotificationSettingsQueryKey(room.id);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getInboxNotificationSettings(room, queryKey);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    function useUpdateRoomNotificationSettings() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((settings)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                id: optimisticUpdateId,\n                type: \"update-notification-settings\",\n                roomId: room.id,\n                settings\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.updateRoomNotificationSettings(settings).then((settings2)=>{\n                store.set((state)=>({\n                        ...state,\n                        notificationSettings: {\n                            [room.id]: settings2\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new UpdateNotificationSettingsError(error, {\n                        roomId: room.id\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useCurrentUserId() {\n        return useSelf((user)=>typeof user.id === \"string\" ? user.id : null);\n    }\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        useMarkThreadAsRead,\n        useThreadSubscription,\n        useRoomNotificationSettings,\n        useUpdateRoomNotificationSettings,\n        ...shared,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction,\n            useMarkThreadAsRead,\n            useThreadSubscription,\n            useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n            useUpdateRoomNotificationSettings,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useCurrentUserId,\n            hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n            useMentionSuggestions\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleApiError(err) {\n    const message = `Request failed with status ${err.status}: ${err.message}`;\n    if (err.details?.error === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction generateQueryKey(roomId, options) {\n    return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options ?? {})}`;\n}\n// src/shared.ts\nfunction useSharedContextBundle() {\n    const roomContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle);\n    const liveblocksContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (roomContextBundle !== null) {\n        return roomContextBundle;\n    } else if (liveblocksContextBundle !== null) {\n        return liveblocksContextBundle;\n    } else {\n        throw new Error(\"LiveblocksProvider or RoomProvider are missing from the React tree.\");\n    }\n}\nvar missingUserError = new Error(\"resolveUsers didn't return anything for this user ID.\");\nvar missingRoomInfoError = new Error(\"resolveRoomsInfo didn't return anything for this room ID.\");\nfunction createSharedContext(client) {\n    const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n    const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n    function useUser(userId) {\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void usersStore.get(userId);\n        }, [\n            userId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return state ? {\n            isLoading: state.isLoading,\n            user: state.data,\n            // Return an error if `undefined` was returned by `resolveUsers` for this user ID\n            error: !state.isLoading && !state.data && !state.error ? missingUserError : state.error\n        } : {\n            isLoading: true\n        };\n    }\n    function useUserSuspense(userId) {\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        const userState = getUserState();\n        if (!userState || userState.isLoading) {\n            throw usersStore.get(userId);\n        }\n        if (userState.error) {\n            throw userState.error;\n        }\n        if (!userState.data) {\n            throw missingUserError;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return {\n            isLoading: false,\n            user: state?.data,\n            error: state?.error\n        };\n    }\n    function useRoomInfo(roomId) {\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void roomsInfoStore.get(roomId);\n        }, [\n            roomId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return state ? {\n            isLoading: state.isLoading,\n            info: state.data,\n            // Return an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n            error: !state.isLoading && !state.data && !state.error ? missingRoomInfoError : state.error\n        } : {\n            isLoading: true\n        };\n    }\n    function useRoomInfoSuspense(roomId) {\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        const roomInfoState = getRoomInfoState();\n        if (!roomInfoState || roomInfoState.isLoading) {\n            throw roomsInfoStore.get(roomId);\n        }\n        if (roomInfoState.error) {\n            throw roomInfoState.error;\n        }\n        if (!roomInfoState.data) {\n            throw missingRoomInfoError;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return {\n            isLoading: false,\n            info: state?.data,\n            error: state?.error\n        };\n    }\n    const bundle = {\n        useUser,\n        useRoomInfo,\n        suspense: {\n            useUser: useUserSuspense,\n            useRoomInfo: useRoomInfoSuspense\n        }\n    };\n    return bundle;\n}\n// src/liveblocks.tsx\nvar ContextBundle2 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useLiveblocksContextBundle() {\n    const bundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (bundle === null) {\n        throw new Error(\"LiveblocksProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nvar POLLING_INTERVAL2 = 60 * 1e3;\nvar INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\nfunction createLiveblocksContext(client) {\n    const shared = createSharedContext(client);\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    const notifications = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications;\n    function LiveblocksProvider(props) {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle2.Provider, {\n            value: bundle\n        }, props.children);\n    }\n    let fetchInboxNotificationsRequest = null;\n    let inboxNotificationsSubscribers = 0;\n    let lastRequestedAt;\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    function refreshThreadsAndNotifications() {\n        return notifications.getInboxNotifications({\n            since: lastRequestedAt\n        }).then((result)=>{\n            lastRequestedAt = result.meta.requestedAt;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n        }, ()=>{});\n    }\n    function incrementInboxNotificationsSubscribers() {\n        inboxNotificationsSubscribers++;\n        poller.start(POLLING_INTERVAL2);\n    }\n    function decrementInboxNotificationsSubscribers() {\n        if (inboxNotificationsSubscribers <= 0) {\n            console.warn(`Internal unexpected behavior. Cannot decrease subscriber count for query \"${INBOX_NOTIFICATIONS_QUERY}\"`);\n            return;\n        }\n        inboxNotificationsSubscribers--;\n        if (inboxNotificationsSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function fetchInboxNotifications({ retryCount } = {\n        retryCount: 0\n    }) {\n        if (fetchInboxNotificationsRequest !== null) {\n            return fetchInboxNotificationsRequest;\n        }\n        store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n            isLoading: true\n        });\n        try {\n            fetchInboxNotificationsRequest = notifications.getInboxNotifications();\n            const result = await fetchInboxNotificationsRequest;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAt = result.meta.requestedAt;\n            }\n            poller.start(POLLING_INTERVAL2);\n        } catch (er) {\n            fetchInboxNotificationsRequest = null;\n            retryError(()=>{\n                void fetchInboxNotifications({\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n                isLoading: false,\n                error: er\n            });\n        }\n        return;\n    }\n    function useInboxNotificationsSelectorCallback(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotifications() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSelectorCallback);\n        return result;\n    }\n    function useInboxNotificationsSuspenseSelector(state) {\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotificationsSuspense() {\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        if (query.error !== void 0) {\n            throw query.error;\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSuspenseSelector);\n    }\n    function selectUnreadInboxNotificationsCount(state) {\n        let count = 0;\n        for (const notification of selectedInboxNotifications(state)){\n            if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n                count++;\n            }\n        }\n        return count;\n    }\n    function useUnreadInboxNotificationsCountSelector(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCount() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSelector);\n    }\n    function useUnreadInboxNotificationsCountSuspenseSelector(state) {\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCountSuspense() {\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSuspenseSelector);\n    }\n    function useMarkInboxNotificationAsRead() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((inboxNotificationId)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId,\n                readAt\n            });\n            notifications.markInboxNotificationAsRead(inboxNotificationId).then(()=>{\n                store.set((state)=>{\n                    const existingNotification = state.inboxNotifications[inboxNotificationId];\n                    if (existingNotification === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                        };\n                    }\n                    return {\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotificationId]: {\n                                ...existingNotification,\n                                readAt\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    };\n                });\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    function useMarkAllInboxNotificationsAsRead() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notifications-as-read\",\n                id: optimisticUpdateId,\n                readAt\n            });\n            notifications.markAllInboxNotificationsAsRead().then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: Object.fromEntries(Array.from(Object.entries(state.inboxNotifications)).map(([id, inboxNotification])=>[\n                                id,\n                                {\n                                    ...inboxNotification,\n                                    readAt\n                                }\n                            ])),\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    function useThreadFromCache(threadId) {\n        const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((state)=>{\n            const thread = state.threads[threadId];\n            if (thread === void 0) {\n                throw new Error(`Internal error: thread with id \"${threadId}\" not found in cache`);\n            }\n            return thread;\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    const currentUserIdStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].currentUserIdStore;\n    function useCurrentUserId() {\n        return (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(currentUserIdStore.subscribe, currentUserIdStore.get, currentUserIdStore.get);\n    }\n    const bundle = {\n        LiveblocksProvider,\n        useInboxNotifications,\n        useUnreadInboxNotificationsCount,\n        useMarkInboxNotificationAsRead,\n        useMarkAllInboxNotificationsAsRead,\n        ...shared,\n        suspense: {\n            LiveblocksProvider,\n            useInboxNotifications: useInboxNotificationsSuspense,\n            useUnreadInboxNotificationsCount: useUnreadInboxNotificationsCountSuspense,\n            useMarkInboxNotificationAsRead,\n            useMarkAllInboxNotificationsAsRead,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useThreadFromCache,\n            useCurrentUserId\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O2lNQUVBLGVBQWU7QUFDZ0M7QUFFL0MsaUJBQWlCO0FBQ2pCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGFBQWE7QUFFakIsNkJBQTZCO0FBQ0U7QUFDL0IsU0FBU0UsbUJBQW1CQyxLQUFLO0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7QUFFQSxxQkFBcUI7QUFDaUU7QUFDM0M7QUFNNUI7QUFDdUY7QUFDZ0M7QUFFdEksbURBQW1EO0FBQ087QUFDMUQsU0FBU3FCLDJCQUEyQkMsS0FBSztJQUN2QyxNQUFNQyxTQUFTSCx3RUFBc0JBLENBQUNFO0lBQ3RDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ0YsT0FBT0csa0JBQWtCLEVBQUVDLElBQUksQ0FDbEQsdURBQXVEO0lBQ3ZELENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsQ0FBQ0MsT0FBTyxLQUFLSCxFQUFFRSxVQUFVLENBQUNDLE9BQU87QUFFM0Q7QUFFQSx5QkFBeUI7QUFDekIsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLHVCQUF1QjtBQUMzQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLFVBQVU7SUFDcEMsSUFBSUEsY0FBY0osdUJBQ2hCO0lBQ0YsTUFBTUssVUFBVUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdILGNBQWNIO0lBQzFDTyxXQUFXO1FBQ1QsS0FBS0w7SUFDUCxHQUFHRTtBQUNMO0FBRUEsZ0JB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UUFDcEI7UUFDQSxDQUFDbGMsdURBQVVBLENBQUMsRUFBRTtZQUNaNGY7WUFDQS9EO1FBQ0Y7SUFDRjtJQUNBLE9BQU94YSxPQUFPK2EsY0FBYyxDQUFDM1QsUUFBUXpJLHVEQUFVQSxFQUFFO1FBQy9DcWMsWUFBWTtJQUNkO0FBQ0Y7QUFFQSxlQUFlO0FBQzBDO0FBQ3pEcmQsNkRBQVdBLENBQUNDLFVBQVVDLGFBQWFDO0FBU2pDLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlnbWEvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanM/Y2QzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBkZXRlY3REdXBlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjEuMTEuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvQ2xpZW50U2lkZVN1c3BlbnNlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBDbGllbnRTaWRlU3VzcGVuc2UocHJvcHMpIHtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7IGZhbGxiYWNrOiBwcm9wcy5mYWxsYmFjayB9LCBtb3VudGVkID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmZhbGxiYWNrKTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQgeyBrSW50ZXJuYWwgYXMga0ludGVybmFsMywgbWFrZVBvbGxlciBhcyBtYWtlUG9sbGVyMiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMyB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCBSZWFjdDMsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9saWIvc2VsZWN0ZWQtaW5ib3gtbm90aWZpY2F0aW9ucy50c1xuaW1wb3J0IHsgYXBwbHlPcHRpbWlzdGljVXBkYXRlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzKHN0YXRlKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykuc29ydChcbiAgICAvLyBTb3J0IHNvIHRoYXQgdGhlIG1vc3QgcmVjZW50IG5vdGlmaWNhdGlvbnMgYXJlIGZpcnN0XG4gICAgKGEsIGIpID0+IGIubm90aWZpZWRBdC5nZXRUaW1lKCkgLSBhLm5vdGlmaWVkQXQuZ2V0VGltZSgpXG4gICk7XG59XG5cbi8vIHNyYy9saWIvcmV0cnktZXJyb3IudHNcbnZhciBNQVhfRVJST1JfUkVUUllfQ09VTlQgPSA1O1xudmFyIEVSUk9SX1JFVFJZX0lOVEVSVkFMID0gNWUzO1xuZnVuY3Rpb24gcmV0cnlFcnJvcihhY3Rpb24sIHJldHJ5Q291bnQpIHtcbiAgaWYgKHJldHJ5Q291bnQgPj0gTUFYX0VSUk9SX1JFVFJZX0NPVU5UKVxuICAgIHJldHVybjtcbiAgY29uc3QgdGltZW91dCA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogRVJST1JfUkVUUllfSU5URVJWQUw7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHZvaWQgYWN0aW9uKCk7XG4gIH0sIHRpbWVvdXQpO1xufVxuXG4vLyBzcmMvc2hhcmVkLnRzXG5pbXBvcnQgeyBrSW50ZXJuYWwgYXMga0ludGVybmFsMiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhZGRSZWFjdGlvbixcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgY29uc29sZSBhcyBjb25zb2xlMixcbiAgZGVsZXRlQ29tbWVudCxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIGlzTGl2ZU5vZGUsXG4gIGtJbnRlcm5hbCxcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIHJlbW92ZVJlYWN0aW9uLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBzdHJpbmdpZnksXG4gIHVwc2VydENvbW1lbnRcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IG5hbm9pZCBhcyBuYW5vaWQyIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9lcnJvcnMudHNcbnZhciBDcmVhdGVUaHJlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIHRocmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlVGhyZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCB0aHJlYWQgbWV0YWRhdGEgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yXCI7XG4gIH1cbn07XG52YXIgQ3JlYXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdENvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0Q29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQWRkUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQWRkIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJBZGRSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgUmVtb3ZlUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiUmVtb3ZlIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJSZW1vdmVSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiVXBkYXRlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWVudHMvbGliL2NyZWF0ZUlkcy50c1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xudmFyIFRIUkVBRF9JRF9QUkVGSVggPSBcInRoXCI7XG52YXIgQ09NTUVOVF9JRF9QUkVGSVggPSBcImNtXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9zZWxlY3Qtbm90aWZpY2F0aW9uLXNldHRpbmdzLnRzXG5pbXBvcnQge1xuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzIGFzIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMyLFxuICBublxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gc2VsZWN0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzdGF0ZSkge1xuICBjb25zdCB7IG5vdGlmaWNhdGlvblNldHRpbmdzIH0gPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzMihzdGF0ZSk7XG4gIHJldHVybiBubihub3RpZmljYXRpb25TZXR0aW5nc1tyb29tSWRdKTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9zZWxlY3RlZC10aHJlYWRzLnRzXG5pbXBvcnQge1xuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzIGFzIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMzXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZFRocmVhZHMocm9vbUlkLCBzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzMyhzdGF0ZSk7XG4gIGNvbnN0IHRocmVhZHMgPSBPYmplY3QudmFsdWVzKHJlc3VsdC50aHJlYWRzKS5maWx0ZXIoKHRocmVhZCkgPT4ge1xuICAgIGlmICh0aHJlYWQucm9vbUlkICE9PSByb29tSWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMucXVlcnk7XG4gICAgaWYgKCFxdWVyeSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5Lm1ldGFkYXRhKSB7XG4gICAgICBpZiAodGhyZWFkLm1ldGFkYXRhW2tleV0gIT09IHF1ZXJ5Lm1ldGFkYXRhW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0aHJlYWRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGIuY3JlYXRlZEF0LmdldFRpbWUoKSk7XG59XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbmltcG9ydCB7IHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlU3RhdGUyKHZhbHVlKVswXTtcbn1cblxuLy8gc3JjL2xpYi91c2UtbGF0ZXN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VMYXRlc3QodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9saWIvdXNlLXJlcmVuZGVyLnRzXG5pbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VSZXJlbmRlcigpIHtcbiAgY29uc3QgWywgdXBkYXRlXSA9IHVzZVJlZHVjZXIoXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBieSBpbmNyZW1lbnRpbmcgYSBoaWRkZW4gY291bnRlciB2YWx1ZSB0aGF0IGlzXG4gICAgLy8gbmV2ZXIgY29uc3VtZWQuIFNpbXBseSBpbmNyZW1lbnRpbmcgdGhlIGNvdW50ZXIgY2hhbmdlcyB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBzdGF0ZSBhbmQsIHRodXMsIHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gICAgKHgpID0+IHggKyAxLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gc3JjL3Jvb20udHN4XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkgPSAoeCkgPT4geDtcbnZhciBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKHJlYWN0VmVyc2lvbiwgcm9vbUlkKSA9PiBgV2Ugbm90aWNlZCB5b3VcXHUyMDE5cmUgdXNpbmcgUmVhY3QgJHtyZWFjdFZlcnNpb259LiBQbGVhc2UgcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhdCB0aGUgUm9vbVByb3ZpZGVyIGxldmVsIHVudGlsIHlvdVxcdTIwMTlyZSByZWFkeSB0byB1cGdyYWRlIHRvIFJlYWN0IDE4OlxuXG4gICAgaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tIFwicmVhY3QtZG9tXCI7ICAvLyBvciBcInJlYWN0LW5hdGl2ZVwiXG5cbiAgICA8Um9vbVByb3ZpZGVyIGlkPSR7SlNPTi5zdHJpbmdpZnkoXG4gIHJvb21JZFxuKX0gLi4uIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPXt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30+XG4gICAgICAuLi5cbiAgICA8L1Jvb21Qcm92aWRlcj5cblxuV2h5PyBQbGVhc2Ugc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3Ryb3VibGVzaG9vdGluZyNzdGFsZS1wcm9wcy16b21iaWUtY2hpbGQgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xudmFyIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gXCJZb3UgZG9uXFx1MjAxOXQgbmVlZCB0byBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIHRvIFJvb21Qcm92aWRlciBhbnltb3JlLCBzaW5jZSB5b3VcXHUyMDE5cmUgb24gUmVhY3QgMTgrIGFscmVhZHkuXCI7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzLCBncywgZ3NzKSB7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzLCBncywgZ3NzLCBpZGVudGl0eSk7XG59XG52YXIgU1RBQkxFX0VNUFRZX0xJU1QgPSBPYmplY3QuZnJlZXplKFtdKTtcbnZhciBQT0xMSU5HX0lOVEVSVkFMID0gNSAqIDYwICogMWUzO1xudmFyIE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UgPSA1MDA7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSB7XG4gIGNvbnN0IGVycm1zZyA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbCBjb25uZWN0ZWQgdG8gdGhlIExpdmVibG9ja3Mgcm9vbVwiO1xuICByZXR1cm4ge1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgY29uc3QgbXV0YWJsZVJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICAgICAgaWYgKG11dGFibGVSb290ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGFibGVSb290O1xuICAgIH0sXG4gICAgZ2V0IHNlbGYoKSB7XG4gICAgICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gICAgICBpZiAoc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgZ2V0IG90aGVycygpIHtcbiAgICAgIGNvbnN0IG90aGVycyA9IHJvb20uZ2V0T3RoZXJzKCk7XG4gICAgICBpZiAocm9vbS5nZXRTZWxmKCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxudmFyIENvbnRleHRCdW5kbGUgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZVJvb21Db250ZXh0QnVuZGxlKCkge1xuICBjb25zdCBidW5kbGUgPSBSZWFjdDIudXNlQ29udGV4dChDb250ZXh0QnVuZGxlKTtcbiAgaWYgKGJ1bmRsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29udGV4dChjbGllbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnM/LnJlc29sdmVVc2Vycykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlICdyZXNvbHZlVXNlcnMnIG9wdGlvbiBoYXMgbW92ZWQgdG8gJ2NyZWF0ZUNsaWVudCcgZnJvbSAnQGxpdmVibG9ja3MvY2xpZW50Jy4gUGxlYXNlIHJlZmVyIHRvIG91ciBVcGdyYWRlIEd1aWRlIHRvIGxlYXJuIG1vcmUsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS91cGdyYWRpbmcvMS4xMC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKG9wdGlvbnM/LnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSAncmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucycgb3B0aW9uIGhhcyBtb3ZlZCB0byAnY3JlYXRlQ2xpZW50JyBmcm9tICdAbGl2ZWJsb2Nrcy9jbGllbnQnLiBQbGVhc2UgcmVmZXIgdG8gb3VyIFVwZ3JhZGUgR3VpZGUgdG8gbGVhcm4gbW9yZSwgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3VwZ3JhZGluZy8xLjEwLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBSb29tQ29udGV4dCA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuICBjb25zdCBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJPdXRlcihwcm9wcykge1xuICAgIGNvbnN0IFtjYWNoZV0gPSBSZWFjdDIudXNlU3RhdGUoXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgKTtcbiAgICBjb25zdCBzdGFibGVFbnRlclJvb20gPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocm9vbUlkLCBvcHRpb25zMikgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQocm9vbUlkKTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBjb25zdCBydiA9IGNsaWVudC5lbnRlclJvb20oXG4gICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgIG9wdGlvbnMyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9yaWdMZWF2ZSA9IHJ2LmxlYXZlO1xuICAgICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgICBjYWNoZS5kZWxldGUocm9vbUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9LFxuICAgICAgW2NhY2hlXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb29tUHJvdmlkZXJJbm5lciwgeyAuLi5wcm9wcywgc3RhYmxlRW50ZXJSb29tIH0pO1xuICB9XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcklubmVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghcm9vbUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBpcyByZXF1aXJlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLXJlYWN0L1Jvb21Qcm92aWRlci1pZC1wcm9wZXJ0eS1pcy1yZXF1aXJlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJvb21JZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ham9yUmVhY3RWZXJzaW9uID0gcGFyc2VJbnQoUmVhY3QyLnZlcnNpb24pIHx8IDE7XG4gICAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgICAgZXJyb3JJZihcbiAgICAgICAgb2xkUmVhY3RWZXJzaW9uICYmIHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID09PSB2b2lkIDAsXG4gICAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICAgICk7XG4gICAgICBkZXByZWNhdGVJZihcbiAgICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgICBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZnJvemVuUHJvcHMgPSB1c2VJbml0aWFsKHtcbiAgICAgIGluaXRpYWxQcmVzZW5jZTogcHJvcHMuaW5pdGlhbFByZXNlbmNlLFxuICAgICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgYXV0b0Nvbm5lY3Q6IHByb3BzLmF1dG9Db25uZWN0ID8/IHByb3BzLnNob3VsZEluaXRpYWxseUNvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgIH0pO1xuICAgIGNvbnN0IFt7IHJvb20gfSwgc2V0Um9vbUxlYXZlUGFpcl0gPSBSZWFjdDIudXNlU3RhdGUoXG4gICAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAgIC4uLmZyb3plblByb3BzLFxuICAgICAgICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgICB9KVxuICAgICk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmdldFRocmVhZCh7XG4gICAgICAgICAgdGhyZWFkSWQ6IG1lc3NhZ2UudGhyZWFkSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uIH0gPSBpbmZvO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0b3JlLmdldCgpLnRocmVhZHNbbWVzc2FnZS50aHJlYWRJZF07XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfRURJVEVEOlxuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfTUVUQURBVEFfVVBEQVRFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9BRERFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEOlxuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0RFTEVURUQ6XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGhyZWFkKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0NSRUFURUQ6XG4gICAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb29tLmV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoXG4gICAgICAgIChtZXNzYWdlKSA9PiB2b2lkIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKVxuICAgICAgKTtcbiAgICB9LCBbcm9vbV0pO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdm9pZCBnZXRUaHJlYWRzVXBkYXRlcyhyb29tLmlkKTtcbiAgICB9LCBbcm9vbS5pZF0pO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICAgIHZvaWQgZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbS5pZCk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tLmlkXSk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBwYWlyID0gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwgZnJvemVuUHJvcHMpO1xuICAgICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICAgIGNvbnN0IHsgcm9vbTogcm9vbTIsIGxlYXZlIH0gPSBwYWlyO1xuICAgICAgaWYgKGZyb3plblByb3BzLmF1dG9Db25uZWN0KSB7XG4gICAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxlYXZlKCk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tSWQsIGZyb3plblByb3BzLCBzdGFibGVFbnRlclJvb21dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRleHRCdW5kbGUuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBidW5kbGVcbiAgICAgIH0sXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3Rpb25JZFNlbGVjdG9yKG90aGVycykge1xuICAgIHJldHVybiBvdGhlcnMubWFwKCh1c2VyKSA9PiB1c2VyLmNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbSgpIHtcbiAgICBjb25zdCByb29tID0gUmVhY3QyLnVzZUNvbnRleHQoUm9vbUNvbnRleHQpO1xuICAgIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RhdHVzKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFByZXNlbmNlO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xuICAgIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgICByZXR1cm4gW3ByZXNlbmNlLCBzZXRQcmVzZW5jZV07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLnVwZGF0ZVByZXNlbmNlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0T3RoZXJzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzRW1wdHlMaXN0O1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvciA/PyBpZGVudGl0eSxcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHVzZU90aGVycyhjb25uZWN0aW9uSWRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKFxuICAgICAgICAob3RoZXIpID0+IFtvdGhlci5jb25uZWN0aW9uSWQsIGl0ZW1TZWxlY3RvcihvdGhlcildXG4gICAgICApLFxuICAgICAgW2l0ZW1TZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZXEgPSBpdGVtSXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoYXR1cGxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiBhdHVwbGVbMF0gPT09IGJ0dXBsZVswXSAmJiBlcShhdHVwbGVbMV0sIGJ0dXBsZVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtpdGVtSXNFcXVhbF1cbiAgICApO1xuICAgIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIH1cbiAgY29uc3QgTk9UX0ZPVU5EID0gU3ltYm9sKCk7XG4gIGZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKFxuICAgICAgICAgIChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgICAgfSxcbiAgICAgIFtjb25uZWN0aW9uSWQsIHNlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocHJldiwgY3VycikgPT4ge1xuICAgICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICAgIHJldHVybiBwcmV2ID09PSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBlcShwcmV2LCBjdXJyKTtcbiAgICAgIH0sXG4gICAgICBbaXNFcXVhbF1cbiAgICApO1xuICAgIGNvbnN0IG90aGVyID0gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICAgIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBzdWNoIG90aGVyIHVzZXIgd2l0aCBjb25uZWN0aW9uIGlkICR7Y29ubmVjdGlvbklkfSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQnJvYWRjYXN0RXZlbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50LCBvcHRpb25zMiA9IHsgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgcm9vbS5icm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KSksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgIChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KVxuICAgICAgKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXJyb3JMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHJvb20uZXZlbnRzLmVycm9yLnN1YnNjcmliZSgoZSkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGUpKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudERhdGEpID0+IHtcbiAgICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50RGF0YSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfSwgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTZWxmKG1heWJlU2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTZWxmO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gbWF5YmVTZWxlY3RvciA/PyBpZGVudGl0eTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90O1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICAgIHJldHVybiBbdXNlTXV0YWJsZVN0b3JhZ2VSb290KCldO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVuZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNhblVuZG8oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgICBjb25zdCBjYW5VbmRvID0gcm9vbS5oaXN0b3J5LmNhblVuZG87XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgY2FuVW5kbywgY2FuVW5kbyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBjYW5SZWRvLCBjYW5SZWRvKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXRjaCgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLmJhdGNoO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxlZ2FjeUtleShrZXkpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCByZXJlbmRlciA9IHVzZVJlcmVuZGVyKCk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGxldCB1bnN1YkN1cnI7XG4gICAgICBsZXQgY3VyciA9IHJvb3QuZ2V0KGtleSk7XG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb0N1cnIoKSB7XG4gICAgICAgIHVuc3ViQ3VyciA9IGlzTGl2ZU5vZGUoY3VycikgPyByb29tLnN1YnNjcmliZShjdXJyLCByZXJlbmRlcikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblJvb3RDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcm9vdC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjdXJyKSB7XG4gICAgICAgICAgdW5zdWJDdXJyPy4oKTtcbiAgICAgICAgICBjdXJyID0gbmV3VmFsdWU7XG4gICAgICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICByZXJlbmRlcigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmVSb290ID0gcm9vbS5zdWJzY3JpYmUocm9vdCwgb25Sb290Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlUm9vdCgpO1xuICAgICAgICB1bnN1YkN1cnI/LigpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vdE9yTnVsbCwgcm9vbSwga2V5LCByZXJlbmRlcl0pO1xuICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3RPck51bGwuZ2V0KGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocm9vdE9yTnVsbDIpID0+IHJvb3RPck51bGwyICE9PSBudWxsID8gc2VsZWN0b3Iocm9vdE9yTnVsbDIpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChvblN0b3JlQ2hhbmdlKSA9PiByb290T3JOdWxsICE9PSBudWxsID8gcm9vbS5zdWJzY3JpYmUocm9vdE9yTnVsbCwgb25TdG9yZUNoYW5nZSwgeyBpc0RlZXA6IHRydWUgfSkgOiBub29wLFxuICAgICAgW3Jvb20sIHJvb3RPck51bGxdXG4gICAgKTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IFJlYWN0Mi51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgICBjb25zdCBpbW0gPSByb290LnRvSW1tdXRhYmxlKCk7XG4gICAgICAgIHJldHVybiBpbW07XG4gICAgICB9XG4gICAgfSwgW3Jvb3RPck51bGxdKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZU5vdFNlcnZlclNpZGUoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHVzZSB0aGUgU3VzcGVuc2UgdmVyc2lvbiBvZiB0aGlzIGhvb2sgb24gdGhlIHNlcnZlciBzaWRlLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHRoZW0gb24gdGhlIGNsaWVudCBzaWRlLlxcbkZvciB0aXBzLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLXJlYWN0I3N1c3BlbnNlLWF2b2lkLXNzclwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICAgIHRocm93IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U2VsZigpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pLFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICBbcm9vbSwgLi4uZGVwc11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU3RvcmFnZShcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU2VsZlN1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU2VsZihcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnMoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSgpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlclN1c3BlbnNlKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VMZWdhY3lLZXlTdXNwZW5zZShrZXkpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZUxlZ2FjeUtleShrZXkpO1xuICB9XG4gIGNvbnN0IHN0b3JlID0gY2xpZW50W2tJbnRlcm5hbF0uY2FjaGVTdG9yZTtcbiAgZnVuY3Rpb24gb25NdXRhdGlvbkZhaWx1cmUoaW5uZXJFcnJvciwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBjcmVhdGVQdWJsaWNFcnJvcikge1xuICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICApXG4gICAgfSkpO1xuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoY3JlYXRlUHVibGljRXJyb3IoZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBOb3RpZmljYXRpb25zQXBpRXJyb3IpIHtcbiAgICAgIGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBpbm5lckVycm9yO1xuICB9XG4gIGNvbnN0IHN1YnNjcmliZXJzQnlRdWVyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlcXVlc3RzQnlRdWVyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHBvbGxlciA9IG1ha2VQb2xsZXIocmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW107XG4gICAgY2xpZW50W2tJbnRlcm5hbF0uZ2V0Um9vbUlkcygpLm1hcCgocm9vbUlkKSA9PiB7XG4gICAgICBjb25zdCByb29tID0gY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgIGlmIChyb29tID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICByZXF1ZXN0cy5wdXNoKGdldFRocmVhZHNVcGRhdGVzKHJvb20uaWQpKTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVxdWVzdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzQnlRdWVyeS5nZXQocXVlcnlLZXkpID8/IDA7XG4gICAgc3Vic2NyaWJlcnNCeVF1ZXJ5LnNldChxdWVyeUtleSwgc3Vic2NyaWJlcnMgKyAxKTtcbiAgICBwb2xsZXIuc3RhcnQoUE9MTElOR19JTlRFUlZBTCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSkge1xuICAgIGNvbnN0IHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnNCeVF1ZXJ5LmdldChxdWVyeUtleSk7XG4gICAgaWYgKHN1YnNjcmliZXJzID09PSB2b2lkIDAgfHwgc3Vic2NyaWJlcnMgPD0gMCkge1xuICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBkZWNyZWFzZSBzdWJzY3JpYmVyIGNvdW50IGZvciBxdWVyeSBcIiR7cXVlcnlLZXl9XCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyc0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCBzdWJzY3JpYmVycyAtIDEpO1xuICAgIGxldCB0b3RhbFN1YnNjcmliZXJzID0gMDtcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXJzMiBvZiBzdWJzY3JpYmVyc0J5UXVlcnkudmFsdWVzKCkpIHtcbiAgICAgIHRvdGFsU3Vic2NyaWJlcnMgKz0gc3Vic2NyaWJlcnMyO1xuICAgIH1cbiAgICBpZiAodG90YWxTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBwb2xsZXIuc3RvcCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zMiwgeyByZXRyeUNvdW50IH0gPSB7IHJldHJ5Q291bnQ6IDAgfSkge1xuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IHJlcXVlc3RzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChleGlzdGluZ1JlcXVlc3QgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBleGlzdGluZ1JlcXVlc3Q7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJvb21ba0ludGVybmFsXS5jb21tZW50cy5nZXRUaHJlYWRzKG9wdGlvbnMyKTtcbiAgICByZXF1ZXN0c0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCByZXF1ZXN0KTtcbiAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDtcbiAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLFxuICAgICAgICByZXN1bHQuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgcXVlcnlLZXlcbiAgICAgICk7XG4gICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSBsYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb20uaWQpO1xuICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSB7XG4gICAgICAgIGxhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbS5pZCwgcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpO1xuICAgICAgfVxuICAgICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVxdWVzdHNCeVF1ZXJ5LmRlbGV0ZShxdWVyeUtleSk7XG4gICAgICByZXRyeUVycm9yKCgpID0+IHtcbiAgICAgICAgdm9pZCBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zMiwge1xuICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgcmV0cnlDb3VudCk7XG4gICAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMID0gMmUzO1xuICBjb25zdCBsYXN0UmVxdWVzdGVkQXRCeVJvb20gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZXF1ZXN0U3RhdHVzQnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IGNsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgaWYgKHJvb20gPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc2luY2UgPSBsYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb20uaWQpO1xuICAgIGlmIChzaW5jZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzRmV0Y2hpbmdUaHJlYWRzVXBkYXRlcyA9IHJlcXVlc3RTdGF0dXNCeVJvb20uZ2V0KHJvb20uaWQpID8/IGZhbHNlO1xuICAgIGlmIChpc0ZldGNoaW5nVGhyZWFkc1VwZGF0ZXMgPT09IHRydWUpXG4gICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIHRydWUpO1xuICAgICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5jb21tZW50cy5nZXRUaHJlYWRzKHsgc2luY2UgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVxdWVzdFN0YXR1c0J5Um9vbS5zZXQocm9vbS5pZCwgZmFsc2UpO1xuICAgICAgfSwgREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCk7XG4gICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgdXBkYXRlcy50aHJlYWRzLFxuICAgICAgICB1cGRhdGVzLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgdXBkYXRlcy5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgbGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tLmlkLCB1cGRhdGVzLm1ldGEucmVxdWVzdGVkQXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVxdWVzdFN0YXR1c0J5Um9vbS5zZXQocm9vbS5pZCwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoaXNRdWVyeUxvYWRpbmcsIHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgICBpZiAoc2hvdWxkU2Nyb2xsT25Mb2FkID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNRdWVyeUxvYWRpbmcgPT09IHRydWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNXaW5kb3dEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBpZiAoIWlzV2luZG93RGVmaW5lZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgY29uc3QgY29tbWVudElkID0gaGFzaC5zbGljZSgxKTtcbiAgICBpZiAoIWNvbW1lbnRJZC5zdGFydHNXaXRoKFwiY21fXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb21tZW50SWQpO1xuICAgIGlmIChjb21tZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gc3RhdGUudGhyZWFkcy5mbGF0TWFwKCh0aHJlYWQpID0+IHRocmVhZC5jb21tZW50cyk7XG4gICAgY29uc3QgaXNDb21tZW50SW5UaHJlYWRzID0gY29tbWVudHMuc29tZShcbiAgICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICAgICk7XG4gICAgaWYgKCFpc0NvbW1lbnRJblRocmVhZHMpXG4gICAgICByZXR1cm47XG4gICAgY29tbWVudC5zY3JvbGxJbnRvVmlldygpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9uczIgPSB7XG4gICAgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH1cbiAgfSkge1xuICAgIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9uczI7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBxdWVyeUtleSA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICAgKCkgPT4gZ2VuZXJhdGVRdWVyeUtleShyb29tLmlkLCBvcHRpb25zMi5xdWVyeSksXG4gICAgICBbcm9vbSwgb3B0aW9uczJdXG4gICAgKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHZvaWQgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9uczIpO1xuICAgICAgaW5jcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgICByZXR1cm4gKCkgPT4gZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgfSwgW3Jvb20sIHF1ZXJ5S2V5XSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUyKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUyLnF1ZXJpZXNbcXVlcnlLZXldO1xuICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRocmVhZHM6IHNlbGVjdGVkVGhyZWFkcyhyb29tLmlkLCBzdGF0ZTIsIG9wdGlvbnMyKSxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBxdWVyeS5lcnJvclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBxdWVyeUtleV1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5pc0xvYWRpbmcgPT09IHRydWUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc3RhdGUuaXNMb2FkaW5nLCBzY3JvbGxPbkxvYWQsIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFdlIG9ubHkgd2FudCB0byBydW4gdGhpcyBlZmZlY3Qgb25jZVxuICAgICAgW3N0YXRlLmlzTG9hZGluZ11cbiAgICApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzU3VzcGVuc2Uob3B0aW9uczIgPSB7XG4gICAgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH1cbiAgfSkge1xuICAgIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9uczI7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBxdWVyeUtleSA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICAgKCkgPT4gZ2VuZXJhdGVRdWVyeUtleShyb29tLmlkLCBvcHRpb25zMi5xdWVyeSksXG4gICAgICBbcm9vbSwgb3B0aW9uczJdXG4gICAgKTtcbiAgICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbcXVlcnlLZXldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9uczIpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXJyb3IpIHtcbiAgICAgIHRocm93IHF1ZXJ5LmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChzdGF0ZTIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aHJlYWRzOiBzZWxlY3RlZFRocmVhZHMocm9vbS5pZCwgc3RhdGUyLCBvcHRpb25zMiksXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBxdWVyeUtleV1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgICB9O1xuICAgIH0sIFtxdWVyeUtleV0pO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHtcbiAgICAgICAgaGFuZGxlU2Nyb2xsVG9Db21tZW50T25Mb2FkKHN0YXRlLmlzTG9hZGluZywgc2Nyb2xsT25Mb2FkLCBzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLSBXZSBvbmx5IHdhbnQgdG8gcnVuIHRoaXMgZWZmZWN0IG9uY2VcbiAgICAgIFtzdGF0ZS5pc0xvYWRpbmddXG4gICAgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlVGhyZWFkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChvcHRpb25zMikgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gb3B0aW9uczIuYm9keTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBcIm1ldGFkYXRhXCIgaW4gb3B0aW9uczIgPyBvcHRpb25zMi5tZXRhZGF0YSA6IHt9O1xuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGNyZWF0ZVRocmVhZElkKCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgbmV3Q29tbWVudCA9IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgcmVhY3Rpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdUaHJlYWQgPSB7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgIHVwZGF0ZWRBdDogY3JlYXRlZEF0LFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBjb21tZW50czogW25ld0NvbW1lbnRdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiY3JlYXRlLXRocmVhZFwiLFxuICAgICAgICAgIHRocmVhZDogbmV3VGhyZWFkLFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5jcmVhdGVUaHJlYWQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBtZXRhZGF0YSB9KS50aGVuKFxuICAgICAgICAgICh0aHJlYWQpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB0aHJlYWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnIyKSA9PiBuZXcgQ3JlYXRlVGhyZWFkRXJyb3IoZXJyMiwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ld1RocmVhZDtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3B0aW9uczIpID0+IHtcbiAgICAgICAgaWYgKCEoXCJtZXRhZGF0YVwiIGluIG9wdGlvbnMyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IG9wdGlvbnMyLnRocmVhZElkO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMyLm1ldGFkYXRhO1xuICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgdXBkYXRlZEF0XG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuZWRpdFRocmVhZE1ldGFkYXRhKHsgbWV0YWRhdGEsIHRocmVhZElkIH0pLnRoZW4oXG4gICAgICAgICAgKG1ldGFkYXRhMikgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ICYmIGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YTJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VBZGRSZWFjdGlvbigpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImFkZC1yZWFjdGlvblwiLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICByZWFjdGlvbjoge1xuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5hZGRSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgICAgKGFkZGVkUmVhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXTogYWRkUmVhY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkUmVhY3Rpb25cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBBZGRSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgICBjb25zdCByZW1vdmVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJyZW1vdmUtcmVhY3Rpb25cIixcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgZW1vamksXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHJlbW92ZWRBdCxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMucmVtb3ZlUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXTogcmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRBdFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IFJlbW92ZVJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBlbW9qaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh7IHRocmVhZElkLCBib2R5IH0pID0+IHtcbiAgICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZWFjdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiY3JlYXRlLWNvbW1lbnRcIixcbiAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5jcmVhdGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KS50aGVuKFxuICAgICAgICAgIChuZXdDb21tZW50KSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgICAgKS5maW5kKChub3RpZmljYXRpb24pID0+IG5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkSWQpO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zID0gaW5ib3hOb3RpZmljYXRpb24gIT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uLmlkXToge1xuICAgICAgICAgICAgICAgICAgLi4uaW5ib3hOb3RpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgICBub3RpZmllZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgICAgICAgIHJlYWRBdDogbmV3Q29tbWVudC5jcmVhdGVkQXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gOiBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHVwc2VydENvbW1lbnQoZXhpc3RpbmdUaHJlYWQsIG5ld0NvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAvLyBVcHNlcnQgdGhlIG5ldyBjb21tZW50IGludG8gdGhlIHRocmVhZCBjb21tZW50cyBsaXN0IChpZiBhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyMikgPT4gbmV3IENyZWF0ZUNvbW1lbnRFcnJvcihlcnIyLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdENvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGVkaXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gc3RvcmUuZ2V0KCkudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIHRocmVhZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAgICAgICAoY29tbWVudDIpID0+IGNvbW1lbnQyLmlkID09PSBjb21tZW50SWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCB8fCBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IFwiJHtjb21tZW50SWR9XCIgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSBjb21tZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiZWRpdC1jb21tZW50XCIsXG4gICAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICAgIGVkaXRlZEF0LFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmVkaXRDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KS50aGVuKFxuICAgICAgICAgIChlZGl0ZWRDb21tZW50KSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHVwc2VydENvbW1lbnQoZXhpc3RpbmdUaHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAvLyBVcHNlcnQgdGhlIGVkaXRlZCBjb21tZW50IGludG8gdGhlIHRocmVhZCBjb21tZW50cyBsaXN0IChpZiBhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IEVkaXRDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS1jb21tZW50XCIsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgIGRlbGV0ZWRBdCxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuZGVsZXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQgfSkudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IGRlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRBdFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IERlbGV0ZUNvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyA9IGNsaWVudFtrSW50ZXJuYWxdLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM7XG4gIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdXNlTWVudGlvblN1Z2dlc3Rpb25zKHNlYXJjaCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgW21lbnRpb25TdWdnZXN0aW9ucywgc2V0TWVudGlvblN1Z2dlc3Rpb25zXSA9IFJlYWN0Mi51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RJbnZva2VkQXQgPSBSZWFjdDIudXNlUmVmKCk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoc2VhcmNoID09PSB2b2lkIDAgfHwgIXJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3MgPSB7IHRleHQ6IHNlYXJjaCwgcm9vbUlkOiByb29tLmlkIH07XG4gICAgICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSA9IHN0cmluZ2lmeShcbiAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3NcbiAgICAgICk7XG4gICAgICBsZXQgZGVib3VuY2VUaW1lb3V0O1xuICAgICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGdldE1lbnRpb25TdWdnZXN0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsYXN0SW52b2tlZEF0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnMyID0gYXdhaXQgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyhcbiAgICAgICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHNldE1lbnRpb25TdWdnZXN0aW9ucyhtZW50aW9uU3VnZ2VzdGlvbnMyKTtcbiAgICAgICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLnNldChcbiAgICAgICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXksXG4gICAgICAgICAgICAgIG1lbnRpb25TdWdnZXN0aW9uczJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUyLmVycm9yKGVycm9yPy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5oYXMobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkpKSB7XG4gICAgICAgIHNldE1lbnRpb25TdWdnZXN0aW9ucyhcbiAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5nZXQobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKCFsYXN0SW52b2tlZEF0LmN1cnJlbnQgfHwgTWF0aC5hYnMocGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0SW52b2tlZEF0LmN1cnJlbnQpID4gTUVOVElPTl9TVUdHRVNUSU9OU19ERUJPVU5DRSkge1xuICAgICAgICB2b2lkIGdldE1lbnRpb25TdWdnZXN0aW9ucygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVib3VuY2VUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHZvaWQgZ2V0TWVudGlvblN1Z2dlc3Rpb25zKCk7XG4gICAgICAgIH0sIE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lb3V0KTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb20uaWQsIHNlYXJjaF0pO1xuICAgIHJldHVybiBtZW50aW9uU3VnZ2VzdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkU3Vic2NyaXB0aW9uKHRocmVhZElkKSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkuZmluZChcbiAgICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24yKSA9PiBpbmJveE5vdGlmaWNhdGlvbjIudGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCB8fCB0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwic3Vic2NyaWJlZFwiLFxuICAgICAgICAgIHVucmVhZFNpbmNlOiBpbmJveE5vdGlmaWNhdGlvbi5yZWFkQXRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbdGhyZWFkSWRdXG4gICAgKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzUmVhZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgIHN0b3JlLmdldCgpLmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICApLmZpbmQoKGluYm94Tm90aWZpY2F0aW9uMikgPT4gaW5ib3hOb3RpZmljYXRpb24yLnRocmVhZElkID09PSB0aHJlYWRJZCk7XG4gICAgICAgIGlmICghaW5ib3hOb3RpZmljYXRpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLm5vdGlmaWNhdGlvbnMubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uLmlkKS50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uLmlkXToge1xuICAgICAgICAgICAgICAgICAgLi4uaW5ib3hOb3RpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IE1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbUlkKSB7XG4gICAgcmV0dXJuIGAke3Jvb21JZH06Tk9USUZJQ0FUSU9OX1NFVFRJTkdTYDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20sIHF1ZXJ5S2V5LCB7IHJldHJ5Q291bnQgfSA9IHsgcmV0cnlDb3VudDogMCB9KSB7XG4gICAgY29uc3QgZXhpc3RpbmdSZXF1ZXN0ID0gcmVxdWVzdHNCeVF1ZXJ5LmdldChxdWVyeUtleSk7XG4gICAgaWYgKGV4aXN0aW5nUmVxdWVzdCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGV4aXN0aW5nUmVxdWVzdDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJvb21ba0ludGVybmFsXS5ub3RpZmljYXRpb25zLmdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgICAgcmVxdWVzdHNCeVF1ZXJ5LnNldChxdWVyeUtleSwgcmVxdWVzdCk7XG4gICAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHJlcXVlc3Q7XG4gICAgICBzdG9yZS51cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBzZXR0aW5ncywgcXVlcnlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVxdWVzdHNCeVF1ZXJ5LmRlbGV0ZShxdWVyeUtleSk7XG4gICAgICByZXRyeUVycm9yKCgpID0+IHtcbiAgICAgICAgdm9pZCBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20sIHF1ZXJ5S2V5LCB7XG4gICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudCArIDFcbiAgICAgICAgfSk7XG4gICAgICB9LCByZXRyeUNvdW50KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUocXVlcnlLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tLmlkKTtcbiAgICAgIHZvaWQgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCBxdWVyeUtleSk7XG4gICAgfSwgW3Jvb21dKTtcbiAgICBjb25zdCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgICBjb25zdCBzZWxlY3RvciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnF1ZXJpZXNbbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbS5pZCldO1xuICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICByZXR1cm4geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBxdWVyeS5lcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBzZXR0aW5nczogc2VsZWN0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbS5pZCwgc3RhdGUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICAgIHJldHVybiBSZWFjdDIudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICAgIH0sIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gICAgY29uc3QgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb20uaWQpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RvcmUuZ2V0KCkucXVlcmllc1txdWVyeUtleV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20sIHF1ZXJ5S2V5KTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yKSB7XG4gICAgICB0aHJvdyBxdWVyeS5lcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIHNldHRpbmdzOiBzZWxlY3ROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBzdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICAgIGNvbnN0IHNldHRpbmdzID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc107XG4gICAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIHNldHRpbmdzXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0ubm90aWZpY2F0aW9ucy51cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpLnRoZW4oXG4gICAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIG5vdGlmaWNhdGlvblNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgW3Jvb20uaWRdOiBzZXR0aW5nczJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IFVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUN1cnJlbnRVc2VySWQoKSB7XG4gICAgcmV0dXJuIHVzZVNlbGYoKHVzZXIpID0+IHR5cGVvZiB1c2VyLmlkID09PSBcInN0cmluZ1wiID8gdXNlci5pZCA6IG51bGwpO1xuICB9XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBSb29tQ29udGV4dCxcbiAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlck91dGVyLFxuICAgIHVzZVJvb20sXG4gICAgdXNlU3RhdHVzLFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICAvLyBUaGVzZSBhcmUganVzdCBhbGlhc2VzLiBUaGUgcGFzc2VkLWluIGtleSB3aWxsIGRlZmluZSB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgIHVzZUxpc3Q6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VNYXA6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VPYmplY3Q6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLi4uc2hhcmVkLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBSb29tQ29udGV4dCxcbiAgICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyT3V0ZXIsXG4gICAgICB1c2VSb29tLFxuICAgICAgdXNlU3RhdHVzLFxuICAgICAgdXNlQmF0Y2gsXG4gICAgICB1c2VCcm9hZGNhc3RFdmVudCxcbiAgICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgICAgdXNlSGlzdG9yeSxcbiAgICAgIHVzZVVuZG8sXG4gICAgICB1c2VSZWRvLFxuICAgICAgdXNlQ2FuUmVkbyxcbiAgICAgIHVzZUNhblVuZG8sXG4gICAgICAvLyBMZWdhY3kgaG9va3NcbiAgICAgIHVzZUxpc3Q6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlTWFwOiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZU9iamVjdDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICAgIHVzZVN0b3JhZ2U6IHVzZVN0b3JhZ2VTdXNwZW5zZSxcbiAgICAgIHVzZVNlbGY6IHVzZVNlbGZTdXNwZW5zZSxcbiAgICAgIHVzZU15UHJlc2VuY2UsXG4gICAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgICAgdXNlT3RoZXJzOiB1c2VPdGhlcnNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc01hcHBlZDogdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzOiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcjogdXNlT3RoZXJTdXNwZW5zZSxcbiAgICAgIHVzZU11dGF0aW9uLFxuICAgICAgdXNlVGhyZWFkczogdXNlVGhyZWFkc1N1c3BlbnNlLFxuICAgICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICAgIHVzZUVkaXRDb21tZW50LFxuICAgICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICAgICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgICAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzOiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgICAgIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH0sXG4gICAgW2tJbnRlcm5hbF06IHtcbiAgICAgIHVzZUN1cnJlbnRVc2VySWQsXG4gICAgICBoYXNSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zICE9PSB2b2lkIDAsXG4gICAgICB1c2VNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCBrSW50ZXJuYWwsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRVc2VySWQocm9vbSkge1xuICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gIGlmIChzZWxmID09PSBudWxsIHx8IHNlbGYuaWQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZWxmLmlkO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBcGlFcnJvcihlcnIpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke2Vyci5zdGF0dXN9OiAke2Vyci5tZXNzYWdlfWA7XG4gIGlmIChlcnIuZGV0YWlscz8uZXJyb3IgPT09IFwiRk9SQklEREVOXCIpIHtcbiAgICBjb25zdCBkZXRhaWxlZE1lc3NhZ2UgPSBbbWVzc2FnZSwgZXJyLmRldGFpbHMuc3VnZ2VzdGlvbiwgZXJyLmRldGFpbHMuZG9jc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgY29uc29sZTIuZXJyb3IoZGV0YWlsZWRNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVRdWVyeUtleShyb29tSWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGAke3Jvb21JZH0tJHtzdHJpbmdpZnkob3B0aW9ucyA/PyB7fSl9YDtcbn1cblxuLy8gc3JjL3NoYXJlZC50c1xuZnVuY3Rpb24gdXNlU2hhcmVkQ29udGV4dEJ1bmRsZSgpIHtcbiAgY29uc3Qgcm9vbUNvbnRleHRCdW5kbGUgPSB1c2VDb250ZXh0MihDb250ZXh0QnVuZGxlKTtcbiAgY29uc3QgbGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUgPSB1c2VDb250ZXh0MihDb250ZXh0QnVuZGxlMik7XG4gIGlmIChyb29tQ29udGV4dEJ1bmRsZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiByb29tQ29udGV4dEJ1bmRsZTtcbiAgfSBlbHNlIGlmIChsaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsaXZlYmxvY2tzQ29udGV4dEJ1bmRsZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkxpdmVibG9ja3NQcm92aWRlciBvciBSb29tUHJvdmlkZXIgYXJlIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIlxuICAgICk7XG4gIH1cbn1cbnZhciBtaXNzaW5nVXNlckVycm9yID0gbmV3IEVycm9yKFxuICBcInJlc29sdmVVc2VycyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciB0aGlzIHVzZXIgSUQuXCJcbik7XG52YXIgbWlzc2luZ1Jvb21JbmZvRXJyb3IgPSBuZXcgRXJyb3IoXG4gIFwicmVzb2x2ZVJvb21zSW5mbyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciB0aGlzIHJvb20gSUQuXCJcbik7XG5mdW5jdGlvbiBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnVzZXJzU3RvcmU7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnJvb21zSW5mb1N0b3JlO1xuICBmdW5jdGlvbiB1c2VVc2VyKHVzZXJJZCkge1xuICAgIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICAgIFt1c2VySWRdXG4gICAgKTtcbiAgICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICAgIHZvaWQgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgICB9LCBbdXNlcklkXSk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICAgIGdldFVzZXJTdGF0ZSxcbiAgICAgIGdldFVzZXJTdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXRlID8ge1xuICAgICAgaXNMb2FkaW5nOiBzdGF0ZS5pc0xvYWRpbmcsXG4gICAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIGlmIGB1bmRlZmluZWRgIHdhcyByZXR1cm5lZCBieSBgcmVzb2x2ZVVzZXJzYCBmb3IgdGhpcyB1c2VyIElEXG4gICAgICBlcnJvcjogIXN0YXRlLmlzTG9hZGluZyAmJiAhc3RhdGUuZGF0YSAmJiAhc3RhdGUuZXJyb3IgPyBtaXNzaW5nVXNlckVycm9yIDogc3RhdGUuZXJyb3JcbiAgICB9IDogeyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVc2VyU3VzcGVuc2UodXNlcklkKSB7XG4gICAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRTdGF0ZSh1c2VySWQpLFxuICAgICAgW3VzZXJJZF1cbiAgICApO1xuICAgIGNvbnN0IHVzZXJTdGF0ZSA9IGdldFVzZXJTdGF0ZSgpO1xuICAgIGlmICghdXNlclN0YXRlIHx8IHVzZXJTdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gICAgfVxuICAgIGlmICh1c2VyU3RhdGUuZXJyb3IpIHtcbiAgICAgIHRocm93IHVzZXJTdGF0ZS5lcnJvcjtcbiAgICB9XG4gICAgaWYgKCF1c2VyU3RhdGUuZGF0YSkge1xuICAgICAgdGhyb3cgbWlzc2luZ1VzZXJFcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICAgIGdldFVzZXJTdGF0ZSxcbiAgICAgIGdldFVzZXJTdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB1c2VyOiBzdGF0ZT8uZGF0YSxcbiAgICAgIGVycm9yOiBzdGF0ZT8uZXJyb3JcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21JbmZvKHJvb21JZCkge1xuICAgIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRTdGF0ZShyb29tSWQpLFxuICAgICAgW3Jvb21JZF1cbiAgICApO1xuICAgIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgICAgdm9pZCByb29tc0luZm9TdG9yZS5nZXQocm9vbUlkKTtcbiAgICB9LCBbcm9vbUlkXSk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgICAgZ2V0Um9vbUluZm9TdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXRlID8ge1xuICAgICAgaXNMb2FkaW5nOiBzdGF0ZS5pc0xvYWRpbmcsXG4gICAgICBpbmZvOiBzdGF0ZS5kYXRhLFxuICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIGlmIGB1bmRlZmluZWRgIHdhcyByZXR1cm5lZCBieSBgcmVzb2x2ZVJvb21zSW5mb2AgZm9yIHRoaXMgcm9vbSBJRFxuICAgICAgZXJyb3I6ICFzdGF0ZS5pc0xvYWRpbmcgJiYgIXN0YXRlLmRhdGEgJiYgIXN0YXRlLmVycm9yID8gbWlzc2luZ1Jvb21JbmZvRXJyb3IgOiBzdGF0ZS5lcnJvclxuICAgIH0gOiB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gICAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgICBbcm9vbUlkXVxuICAgICk7XG4gICAgY29uc3Qgcm9vbUluZm9TdGF0ZSA9IGdldFJvb21JbmZvU3RhdGUoKTtcbiAgICBpZiAoIXJvb21JbmZvU3RhdGUgfHwgcm9vbUluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IHJvb21zSW5mb1N0b3JlLmdldChyb29tSWQpO1xuICAgIH1cbiAgICBpZiAocm9vbUluZm9TdGF0ZS5lcnJvcikge1xuICAgICAgdGhyb3cgcm9vbUluZm9TdGF0ZS5lcnJvcjtcbiAgICB9XG4gICAgaWYgKCFyb29tSW5mb1N0YXRlLmRhdGEpIHtcbiAgICAgIHRocm93IG1pc3NpbmdSb29tSW5mb0Vycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgICBnZXRSb29tSW5mb1N0YXRlXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGluZm86IHN0YXRlPy5kYXRhLFxuICAgICAgZXJyb3I6IHN0YXRlPy5lcnJvclxuICAgIH07XG4gIH1cbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIHVzZVVzZXIsXG4gICAgdXNlUm9vbUluZm8sXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIHVzZVVzZXI6IHVzZVVzZXJTdXNwZW5zZSxcbiAgICAgIHVzZVJvb21JbmZvOiB1c2VSb29tSW5mb1N1c3BlbnNlXG4gICAgfVxuICB9O1xuICByZXR1cm4gYnVuZGxlO1xufVxuXG4vLyBzcmMvbGl2ZWJsb2Nrcy50c3hcbnZhciBDb250ZXh0QnVuZGxlMiA9IGNyZWF0ZUNvbnRleHQyKG51bGwpO1xuZnVuY3Rpb24gdXNlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoKSB7XG4gIGNvbnN0IGJ1bmRsZSA9IHVzZUNvbnRleHQzKENvbnRleHRCdW5kbGUyKTtcbiAgaWYgKGJ1bmRsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkxpdmVibG9ja3NQcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG52YXIgUE9MTElOR19JTlRFUlZBTDIgPSA2MCAqIDFlMztcbnZhciBJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZID0gXCJJTkJPWF9OT1RJRklDQVRJT05TXCI7XG5mdW5jdGlvbiBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dChjbGllbnQpIHtcbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5jYWNoZVN0b3JlO1xuICBjb25zdCBub3RpZmljYXRpb25zID0gY2xpZW50W2tJbnRlcm5hbDNdLm5vdGlmaWNhdGlvbnM7XG4gIGZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcihwcm9wcykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb250ZXh0QnVuZGxlMi5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IGJ1bmRsZVxuICAgICAgfSxcbiAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxuICBsZXQgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0ID0gbnVsbDtcbiAgbGV0IGluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzID0gMDtcbiAgbGV0IGxhc3RSZXF1ZXN0ZWRBdDtcbiAgY29uc3QgcG9sbGVyID0gbWFrZVBvbGxlcjIocmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKTtcbiAgZnVuY3Rpb24gcmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKCkge1xuICAgIHJldHVybiBub3RpZmljYXRpb25zLmdldEluYm94Tm90aWZpY2F0aW9ucyh7IHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQgfSkudGhlbihcbiAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgbGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQ7XG4gICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLFxuICAgICAgICAgIHJlc3VsdC5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIElOQk9YX05PVElGSUNBVElPTlNfUVVFUllcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpIHtcbiAgICBpbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycysrO1xuICAgIHBvbGxlci5zdGFydChQT0xMSU5HX0lOVEVSVkFMMik7XG4gIH1cbiAgZnVuY3Rpb24gZGVjcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKSB7XG4gICAgaWYgKGluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBkZWNyZWFzZSBzdWJzY3JpYmVyIGNvdW50IGZvciBxdWVyeSBcIiR7SU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWX1cImBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzLS07XG4gICAgaWYgKGluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzIDw9IDApIHtcbiAgICAgIHBvbGxlci5zdG9wKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoSW5ib3hOb3RpZmljYXRpb25zKHsgcmV0cnlDb3VudCB9ID0geyByZXRyeUNvdW50OiAwIH0pIHtcbiAgICBpZiAoZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0O1xuICAgIH1cbiAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKElOQk9YX05PVElGSUNBVElPTlNfUVVFUlksIHtcbiAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3QgPSBub3RpZmljYXRpb25zLmdldEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0O1xuICAgICAgc3RvcmUudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICByZXN1bHQuZGVsZXRlZFRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICBJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXG4gICAgICApO1xuICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSB7XG4gICAgICAgIGxhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0O1xuICAgICAgfVxuICAgICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwyKTtcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHJldHJ5RXJyb3IoKCkgPT4ge1xuICAgICAgICB2b2lkIGZldGNoSW5ib3hOb3RpZmljYXRpb25zKHtcbiAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sIHJldHJ5Q291bnQpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZLCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBmdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTZWxlY3RvckNhbGxiYWNrKHN0YXRlKSB7XG4gICAgY29uc3QgcXVlcnkgPSBzdGF0ZS5xdWVyaWVzW0lOQk9YX05PVElGSUNBVElPTlNfUVVFUlldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHF1ZXJ5LmVycm9yLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSksXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgICB2b2lkIGZldGNoSW5ib3hOb3RpZmljYXRpb25zKCk7XG4gICAgICBpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgcmV0dXJuICgpID0+IGRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uc1NlbGVjdG9yQ2FsbGJhY2tcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2VTZWxlY3RvcihzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlKCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RvcmUuZ2V0KCkucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IGZldGNoSW5ib3hOb3RpZmljYXRpb25zKCk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBxdWVyeS5lcnJvcjtcbiAgICB9XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVjcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZVNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChzdGF0ZSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBub3RpZmljYXRpb24gb2Ygc2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMoc3RhdGUpKSB7XG4gICAgICBpZiAobm90aWZpY2F0aW9uLnJlYWRBdCA9PT0gbnVsbCB8fCBub3RpZmljYXRpb24ucmVhZEF0IDwgbm90aWZpY2F0aW9uLm5vdGlmaWVkQXQpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U2VsZWN0b3Ioc3RhdGUpIHtcbiAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnF1ZXJpZXNbSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcXVlcnkuZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgY291bnQ6IHNlbGVjdFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHN0YXRlKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgICB2b2lkIGZldGNoSW5ib3hOb3RpZmljYXRpb25zKCk7XG4gICAgICBpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgcmV0dXJuICgpID0+IGRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlU2VsZWN0b3Ioc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGNvdW50OiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChzdGF0ZSlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UoKSB7XG4gICAgY29uc3QgcXVlcnkgPSBzdG9yZS5nZXQoKS5xdWVyaWVzW0lOQk9YX05PVElGSUNBVElPTlNfUVVFUlldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoKTtcbiAgICB9XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVjcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlU2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCgpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2szKChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIHJlYWRBdFxuICAgICAgfSk7XG4gICAgICBub3RpZmljYXRpb25zLm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdOb3RpZmljYXRpb24gPSBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNbaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uSWRdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ05vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICAgIHJlYWRBdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQzKCk7XG4gICAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbnMtYXMtcmVhZFwiLFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICByZWFkQXRcbiAgICAgIH0pO1xuICAgICAgbm90aWZpY2F0aW9ucy5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICBBcnJheS5mcm9tKE9iamVjdC5lbnRyaWVzKHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucykpLm1hcChcbiAgICAgICAgICAgICAgICAoW2lkLCBpbmJveE5vdGlmaWNhdGlvbl0pID0+IFtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgeyAuLi5pbmJveE5vdGlmaWNhdGlvbiwgcmVhZEF0IH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRGcm9tQ2FjaGUodGhyZWFkSWQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMyhcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludGVybmFsIGVycm9yOiB0aHJlYWQgd2l0aCBpZCBcIiR7dGhyZWFkSWR9XCIgbm90IGZvdW5kIGluIGNhY2hlYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRocmVhZDtcbiAgICAgIH0sXG4gICAgICBbdGhyZWFkSWRdXG4gICAgKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRVc2VySWRTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5jdXJyZW50VXNlcklkU3RvcmU7XG4gIGZ1bmN0aW9uIHVzZUN1cnJlbnRVc2VySWQoKSB7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhcbiAgICAgIGN1cnJlbnRVc2VySWRTdG9yZS5zdWJzY3JpYmUsXG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuZ2V0LFxuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLmdldFxuICAgICk7XG4gIH1cbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIExpdmVibG9ja3NQcm92aWRlcixcbiAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgLi4uc2hhcmVkLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6IHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlLFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UsXG4gICAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgLi4uc2hhcmVkLnN1c3BlbnNlXG4gICAgfSxcbiAgICBba0ludGVybmFsM106IHtcbiAgICAgIHVzZVRocmVhZEZyb21DYWNoZSxcbiAgICAgIHVzZUN1cnJlbnRVc2VySWRcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCBrSW50ZXJuYWwzLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgc2hhbGxvdyBhcyBzaGFsbG93MiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRTaWRlU3VzcGVuc2UsXG4gIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0LFxuICBjcmVhdGVSb29tQ29udGV4dCxcbiAgc2hhbGxvdzIgYXMgc2hhbGxvdyxcbiAgdXNlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUsXG4gIHVzZVJvb21Db250ZXh0QnVuZGxlLFxuICB1c2VTaGFyZWRDb250ZXh0QnVuZGxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJkZXRlY3REdXBlcyIsIlBLR19OQU1FIiwiUEtHX1ZFUlNJT04iLCJQS0dfRk9STUFUIiwiUmVhY3QiLCJDbGllbnRTaWRlU3VzcGVuc2UiLCJwcm9wcyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImNoaWxkcmVuIiwia0ludGVybmFsIiwia0ludGVybmFsMyIsIm1ha2VQb2xsZXIiLCJtYWtlUG9sbGVyMiIsIm5hbm9pZCIsIm5hbm9pZDMiLCJSZWFjdDMiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dDIiLCJ1c2VDYWxsYmFjayIsInVzZUNhbGxiYWNrMyIsInVzZUNvbnRleHQiLCJ1c2VDb250ZXh0MyIsInVzZUVmZmVjdDUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlMyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIiwiYXBwbHlPcHRpbWlzdGljVXBkYXRlcyIsInNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zIiwic3RhdGUiLCJyZXN1bHQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJpbmJveE5vdGlmaWNhdGlvbnMiLCJzb3J0IiwiYSIsImIiLCJub3RpZmllZEF0IiwiZ2V0VGltZSIsIk1BWF9FUlJPUl9SRVRSWV9DT1VOVCIsIkVSUk9SX1JFVFJZX0lOVEVSVkFMIiwicmV0cnlFcnJvciIsImFjdGlvbiIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInBvdyIsInNldFRpbWVvdXQiLCJrSW50ZXJuYWwyIiwidXNlQ2FsbGJhY2syIiwidXNlQ29udGV4dDIiLCJ1c2VFZmZlY3Q0IiwidXNlU3luY0V4dGVybmFsU3RvcmUyIiwic2hhbGxvdyIsImFkZFJlYWN0aW9uIiwiQ29tbWVudHNBcGlFcnJvciIsImNvbnNvbGUiLCJjb25zb2xlMiIsImRlbGV0ZUNvbW1lbnQiLCJkZXByZWNhdGVJZiIsImVycm9ySWYiLCJpc0xpdmVOb2RlIiwibWFrZUV2ZW50U291cmNlIiwiTm90aWZpY2F0aW9uc0FwaUVycm9yIiwicmVtb3ZlUmVhY3Rpb24iLCJTZXJ2ZXJNc2dDb2RlIiwic3RyaW5naWZ5IiwidXBzZXJ0Q29tbWVudCIsIm5hbm9pZDIiLCJSZWFjdDIiLCJDcmVhdGVUaHJlYWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjYXVzZSIsImNvbnRleHQiLCJuYW1lIiwiRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IiLCJDcmVhdGVDb21tZW50RXJyb3IiLCJFZGl0Q29tbWVudEVycm9yIiwiRGVsZXRlQ29tbWVudEVycm9yIiwiQWRkUmVhY3Rpb25FcnJvciIsIlJlbW92ZVJlYWN0aW9uRXJyb3IiLCJNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvciIsIlVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IiLCJUSFJFQURfSURfUFJFRklYIiwiQ09NTUVOVF9JRF9QUkVGSVgiLCJjcmVhdGVPcHRpbWlzdGljSWQiLCJwcmVmaXgiLCJjcmVhdGVUaHJlYWRJZCIsImNyZWF0ZUNvbW1lbnRJZCIsImFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMyIiwibm4iLCJzZWxlY3ROb3RpZmljYXRpb25TZXR0aW5ncyIsInJvb21JZCIsIm5vdGlmaWNhdGlvblNldHRpbmdzIiwiYXBwbHlPcHRpbWlzdGljVXBkYXRlczMiLCJzZWxlY3RlZFRocmVhZHMiLCJvcHRpb25zIiwidGhyZWFkcyIsImZpbHRlciIsInRocmVhZCIsImRlbGV0ZWRBdCIsInF1ZXJ5Iiwia2V5IiwibWV0YWRhdGEiLCJjcmVhdGVkQXQiLCJ1c2VTdGF0ZTIiLCJ1c2VJbml0aWFsIiwidmFsdWUiLCJ1c2VFZmZlY3QyIiwidXNlUmVmIiwidXNlTGF0ZXN0IiwicmVmIiwiY3VycmVudCIsInVzZVJlZHVjZXIiLCJ1c2VSZXJlbmRlciIsInVwZGF0ZSIsIngiLCJub29wIiwiaWRlbnRpdHkiLCJtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwicmVhY3RWZXJzaW9uIiwiSlNPTiIsInN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwicyIsImdzIiwiZ3NzIiwiU1RBQkxFX0VNUFRZX0xJU1QiLCJmcmVlemUiLCJQT0xMSU5HX0lOVEVSVkFMIiwiTUVOVElPTl9TVUdHRVNUSU9OU19ERUJPVU5DRSIsImFsd2F5c0VtcHR5TGlzdCIsImFsd2F5c051bGwiLCJtYWtlTXV0YXRpb25Db250ZXh0Iiwicm9vbSIsImVycm1zZyIsInN0b3JhZ2UiLCJtdXRhYmxlUm9vdCIsImdldFN0b3JhZ2VTbmFwc2hvdCIsInNlbGYiLCJnZXRTZWxmIiwib3RoZXJzIiwiZ2V0T3RoZXJzIiwic2V0TXlQcmVzZW5jZSIsInVwZGF0ZVByZXNlbmNlIiwiQ29udGV4dEJ1bmRsZSIsInVzZVJvb21Db250ZXh0QnVuZGxlIiwiYnVuZGxlIiwiY3JlYXRlUm9vbUNvbnRleHQiLCJjbGllbnQiLCJyZXNvbHZlVXNlcnMiLCJyZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIiwiUm9vbUNvbnRleHQiLCJjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UiLCJzaGFyZWQiLCJjcmVhdGVTaGFyZWRDb250ZXh0IiwiUm9vbVByb3ZpZGVyT3V0ZXIiLCJjYWNoZSIsIk1hcCIsInN0YWJsZUVudGVyUm9vbSIsIm9wdGlvbnMyIiwiY2FjaGVkIiwiZ2V0IiwicnYiLCJlbnRlclJvb20iLCJvcmlnTGVhdmUiLCJsZWF2ZSIsImRlbGV0ZSIsInNldCIsIlJvb21Qcm92aWRlcklubmVyIiwiaWQiLCJwcm9jZXNzIiwibWFqb3JSZWFjdFZlcnNpb24iLCJwYXJzZUludCIsInZlcnNpb24iLCJvbGRSZWFjdFZlcnNpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImZyb3plblByb3BzIiwiaW5pdGlhbFByZXNlbmNlIiwiaW5pdGlhbFN0b3JhZ2UiLCJhdXRvQ29ubmVjdCIsInNob3VsZEluaXRpYWxseUNvbm5lY3QiLCJzZXRSb29tTGVhdmVQYWlyIiwiaGFuZGxlQ29tbWVudEV2ZW50IiwibWVzc2FnZSIsImluZm8iLCJjb21tZW50cyIsImdldFRocmVhZCIsInRocmVhZElkIiwic3RvcmUiLCJkZWxldGVUaHJlYWQiLCJpbmJveE5vdGlmaWNhdGlvbiIsImV4aXN0aW5nVGhyZWFkIiwidHlwZSIsIkNPTU1FTlRfRURJVEVEIiwiVEhSRUFEX01FVEFEQVRBX1VQREFURUQiLCJDT01NRU5UX1JFQUNUSU9OX0FEREVEIiwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEIiwiQ09NTUVOVF9ERUxFVEVEIiwidXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uIiwiQ09NTUVOVF9DUkVBVEVEIiwiZXZlbnRzIiwic3Vic2NyaWJlIiwiZ2V0VGhyZWFkc1VwZGF0ZXMiLCJoYW5kbGVJc09ubGluZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFpciIsInJvb20yIiwiY29ubmVjdCIsIlByb3ZpZGVyIiwiY29ubmVjdGlvbklkU2VsZWN0b3IiLCJtYXAiLCJ1c2VyIiwiY29ubmVjdGlvbklkIiwidXNlUm9vbSIsInVzZVN0YXR1cyIsInN0YXR1cyIsImdldFNuYXBzaG90IiwiZ2V0U3RhdHVzIiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VNeVByZXNlbmNlIiwibXlQcmVzZW5jZSIsImdldFByZXNlbmNlIiwicHJlc2VuY2UiLCJzZXRQcmVzZW5jZSIsInVzZVVwZGF0ZU15UHJlc2VuY2UiLCJ1c2VPdGhlcnMiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJ1c2VPdGhlcnNDb25uZWN0aW9uSWRzIiwidXNlT3RoZXJzTWFwcGVkIiwiaXRlbVNlbGVjdG9yIiwiaXRlbUlzRXF1YWwiLCJ3cmFwcGVkU2VsZWN0b3IiLCJvdGhlciIsIndyYXBwZWRJc0VxdWFsIiwiZXEiLCJpcyIsImxlbmd0aCIsImV2ZXJ5IiwiYXR1cGxlIiwiaW5kZXgiLCJidHVwbGUiLCJOT1RfRk9VTkQiLCJTeW1ib2wiLCJ1c2VPdGhlciIsIm90aGVyMiIsImZpbmQiLCJvdGhlcjMiLCJwcmV2IiwiY3VyciIsInVzZUJyb2FkY2FzdEV2ZW50IiwiZXZlbnQiLCJzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSIsImJyb2FkY2FzdEV2ZW50IiwidXNlT3RoZXJzTGlzdGVuZXIiLCJjYWxsYmFjayIsInNhdmVkQ2FsbGJhY2siLCJ1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyIiwibG9zdENvbm5lY3Rpb24iLCJ1c2VFcnJvckxpc3RlbmVyIiwiZXJyb3IiLCJlIiwidXNlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZXZlbnREYXRhIiwiY3VzdG9tRXZlbnQiLCJ1c2VTZWxmIiwibWF5YmVTZWxlY3RvciIsIm1lIiwidXNlTXV0YWJsZVN0b3JhZ2VSb290Iiwic3RvcmFnZURpZExvYWQiLCJzdWJzY3JpYmVPbmNlIiwidXNlU3RvcmFnZVJvb3QiLCJ1c2VIaXN0b3J5IiwiaGlzdG9yeSIsInVzZVVuZG8iLCJ1bmRvIiwidXNlUmVkbyIsInJlZG8iLCJ1c2VDYW5VbmRvIiwiY2FuVW5kbyIsInVzZUNhblJlZG8iLCJjYW5SZWRvIiwidXNlQmF0Y2giLCJiYXRjaCIsInVzZUxlZ2FjeUtleSIsInJvb3RPck51bGwiLCJyZXJlbmRlciIsInJvb3QiLCJ1bnN1YkN1cnIiLCJzdWJzY3JpYmVUb0N1cnIiLCJvblJvb3RDaGFuZ2UiLCJuZXdWYWx1ZSIsInVuc3Vic2NyaWJlUm9vdCIsInVzZVN0b3JhZ2UiLCJyb290T3JOdWxsMiIsIm9uU3RvcmVDaGFuZ2UiLCJpc0RlZXAiLCJpbW0iLCJ0b0ltbXV0YWJsZSIsImVuc3VyZU5vdFNlcnZlclNpZGUiLCJ1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkIiwiUHJvbWlzZSIsInJlcyIsInVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkIiwidXNlTXV0YXRpb24iLCJkZXBzIiwidXNlTWVtbyIsImFyZ3MiLCJ1c2VTdG9yYWdlU3VzcGVuc2UiLCJ1c2VTZWxmU3VzcGVuc2UiLCJ1c2VPdGhlcnNTdXNwZW5zZSIsInVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSIsInVzZU90aGVyc01hcHBlZFN1c3BlbnNlIiwidXNlT3RoZXJTdXNwZW5zZSIsInVzZUxlZ2FjeUtleVN1c3BlbnNlIiwiY2FjaGVTdG9yZSIsIm9uTXV0YXRpb25GYWlsdXJlIiwiaW5uZXJFcnJvciIsIm9wdGltaXN0aWNVcGRhdGVJZCIsImNyZWF0ZVB1YmxpY0Vycm9yIiwib3B0aW1pc3RpY1VwZGF0ZXMiLCJoYW5kbGVBcGlFcnJvciIsIm5vdGlmeSIsInN1YnNjcmliZXJzQnlRdWVyeSIsInJlcXVlc3RzQnlRdWVyeSIsInBvbGxlciIsInJlZnJlc2hUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyIsInJlcXVlc3RzIiwiZ2V0Um9vbUlkcyIsImdldFJvb20iLCJwdXNoIiwiYWxsU2V0dGxlZCIsImluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMiLCJxdWVyeUtleSIsInN1YnNjcmliZXJzIiwic3RhcnQiLCJkZWNyZW1lbnRRdWVyeVN1YnNjcmliZXJzIiwid2FybiIsInRvdGFsU3Vic2NyaWJlcnMiLCJzdWJzY3JpYmVyczIiLCJzdG9wIiwiZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyIsImV4aXN0aW5nUmVxdWVzdCIsInJlcXVlc3QiLCJnZXRUaHJlYWRzIiwic2V0UXVlcnlTdGF0ZSIsImlzTG9hZGluZyIsInVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zIiwiZGVsZXRlZFRocmVhZHMiLCJkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zIiwibGFzdFJlcXVlc3RlZEF0IiwibGFzdFJlcXVlc3RlZEF0QnlSb29tIiwibWV0YSIsInJlcXVlc3RlZEF0IiwiZXJyIiwiREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCIsInJlcXVlc3RTdGF0dXNCeVJvb20iLCJzaW5jZSIsImlzRmV0Y2hpbmdUaHJlYWRzVXBkYXRlcyIsInVwZGF0ZXMiLCJoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQiLCJpc1F1ZXJ5TG9hZGluZyIsInNob3VsZFNjcm9sbE9uTG9hZCIsImlzV2luZG93RGVmaW5lZCIsImhhc2giLCJsb2NhdGlvbiIsImNvbW1lbnRJZCIsInNsaWNlIiwic3RhcnRzV2l0aCIsImNvbW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZmxhdE1hcCIsImlzQ29tbWVudEluVGhyZWFkcyIsInNvbWUiLCJjb21tZW50MiIsInNjcm9sbEludG9WaWV3IiwidXNlVGhyZWFkcyIsInNjcm9sbE9uTG9hZCIsImdlbmVyYXRlUXVlcnlLZXkiLCJzdGF0ZTIiLCJxdWVyaWVzIiwidXNlVGhyZWFkc1N1c3BlbnNlIiwidXNlQ3JlYXRlVGhyZWFkIiwiYm9keSIsIkRhdGUiLCJuZXdDb21tZW50IiwidXNlcklkIiwiZ2V0Q3VycmVudFVzZXJJZCIsInJlYWN0aW9ucyIsIm5ld1RocmVhZCIsInVwZGF0ZWRBdCIsInB1c2hPcHRpbWlzdGljVXBkYXRlIiwiY3JlYXRlVGhyZWFkIiwidGhlbiIsImVycjIiLCJ1c2VFZGl0VGhyZWFkTWV0YWRhdGEiLCJlZGl0VGhyZWFkTWV0YWRhdGEiLCJtZXRhZGF0YTIiLCJ1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMiLCJ1c2VBZGRSZWFjdGlvbiIsImVtb2ppIiwicmVhY3Rpb24iLCJhZGRlZFJlYWN0aW9uIiwidXNlUmVtb3ZlUmVhY3Rpb24iLCJyZW1vdmVkQXQiLCJ1c2VDcmVhdGVDb21tZW50IiwiY3JlYXRlQ29tbWVudCIsIm5vdGlmaWNhdGlvbiIsInVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMiLCJyZWFkQXQiLCJ1c2VFZGl0Q29tbWVudCIsImVkaXRlZEF0IiwiZWRpdENvbW1lbnQiLCJlZGl0ZWRDb21tZW50IiwidXNlRGVsZXRlQ29tbWVudCIsIm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlIiwidXNlTWVudGlvblN1Z2dlc3Rpb25zIiwic2VhcmNoIiwibWVudGlvblN1Z2dlc3Rpb25zIiwic2V0TWVudGlvblN1Z2dlc3Rpb25zIiwibGFzdEludm9rZWRBdCIsInJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzIiwidGV4dCIsIm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5IiwiZGVib3VuY2VUaW1lb3V0IiwiaXNDYW5jZWxlZCIsImdldE1lbnRpb25TdWdnZXN0aW9ucyIsInBlcmZvcm1hbmNlIiwibm93IiwibWVudGlvblN1Z2dlc3Rpb25zMiIsImhhcyIsImFicyIsImNsZWFyVGltZW91dCIsInVzZVRocmVhZFN1YnNjcmlwdGlvbiIsImluYm94Tm90aWZpY2F0aW9uMiIsInVucmVhZFNpbmNlIiwidXNlTWFya1RocmVhZEFzUmVhZCIsImluYm94Tm90aWZpY2F0aW9uSWQiLCJub3RpZmljYXRpb25zIiwibWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkIiwibWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkiLCJnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzIiwiZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzIiwic2V0dGluZ3MiLCJ1cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlIiwic2V0dGluZ3MyIiwidXNlQ3VycmVudFVzZXJJZCIsIlJvb21Qcm92aWRlciIsInVzZUxpc3QiLCJ1c2VNYXAiLCJ1c2VPYmplY3QiLCJzdXNwZW5zZSIsImhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJkZXRhaWxzIiwiZGV0YWlsZWRNZXNzYWdlIiwic3VnZ2VzdGlvbiIsImRvY3MiLCJCb29sZWFuIiwiam9pbiIsInVzZVNoYXJlZENvbnRleHRCdW5kbGUiLCJyb29tQ29udGV4dEJ1bmRsZSIsImxpdmVibG9ja3NDb250ZXh0QnVuZGxlIiwiQ29udGV4dEJ1bmRsZTIiLCJtaXNzaW5nVXNlckVycm9yIiwibWlzc2luZ1Jvb21JbmZvRXJyb3IiLCJ1c2Vyc1N0b3JlIiwicm9vbXNJbmZvU3RvcmUiLCJ1c2VVc2VyIiwiZ2V0VXNlclN0YXRlIiwiZ2V0U3RhdGUiLCJkYXRhIiwidXNlVXNlclN1c3BlbnNlIiwidXNlclN0YXRlIiwidXNlUm9vbUluZm8iLCJnZXRSb29tSW5mb1N0YXRlIiwidXNlUm9vbUluZm9TdXNwZW5zZSIsInJvb21JbmZvU3RhdGUiLCJ1c2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSIsIlBPTExJTkdfSU5URVJWQUwyIiwiSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSIsImNyZWF0ZUxpdmVibG9ja3NDb250ZXh0IiwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIiwiZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0IiwiaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMiLCJnZXRJbmJveE5vdGlmaWNhdGlvbnMiLCJpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyIsImRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzIiwiZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMiLCJlciIsInVzZUluYm94Tm90aWZpY2F0aW9uc1NlbGVjdG9yQ2FsbGJhY2siLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnMiLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZVNlbGVjdG9yIiwidXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UiLCJzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCIsImNvdW50IiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTZWxlY3RvciIsInVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50IiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZVNlbGVjdG9yIiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSIsInVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsImV4aXN0aW5nTm90aWZpY2F0aW9uIiwidXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCIsIm1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJmcm9tRW50cmllcyIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJ1c2VUaHJlYWRGcm9tQ2FjaGUiLCJjdXJyZW50VXNlcklkU3RvcmUiLCJzaGFsbG93MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/index.mjs\n");

/***/ })

};
;